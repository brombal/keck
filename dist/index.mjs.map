{"mappings":";;AGAA;AAEA,MAAM,6BAAO,OAAO;AAEb,SAAS,0CAAO,KAAQ,EAAK;IAClC,MAAM,UAAU,SAAS,CAAA,GAAA,yCAAmB,AAAD,EAAE,GAAG,CAAC,MAAM,WAAW;IAClE,IAAI,CAAC,SAAS,OAAO;IACpB,KAAa,CAAC,2BAAK,GAAG,IAAI;IAC3B,OAAO;AACT;AAEO,SAAS,0CAAS,KAAQ,EAAW;IAC1C,OAAO,CAAC,CAAE,OAAe,CAAC,2BAAK;AACjC;;ADbA;AAEA,wBAAwB;AAExB;;CAEC,GACD,MAAM,sCAAgB,IAAI;AAE1B,MAAM,uCAAiB,OAAO;AAI9B;;CAEC,GACD,MAAM,6CAAuB,IAAI;AAajC;;;;;CAKC,GACD,MAAM;IAsBJ,YACS,QACA,YACA,MACP;sBAHO;0BACA;qBACA;aAtBF,WAAW,IAAI;aAYN,oBAAoB,IAAI;aAKjC,gBAAgB,IAAI;QAOzB,IAAI,CAAC,0CAAoB,GAAG,CAAC,MAAM,WAAW,GAC5C,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,MAAM,mBAAmB,CAAC,EAAE;QAExD,IAAI,CAAC,QAAQ,oCAAc,GAAG,CAAC,OAAO,IAAI;aACrC,OAAO,QAAQ,CAAC,GAAG,CAAC,YAAY,IAAI;IAC3C;IAEO,UAAU;QACf,OAAO,0CAAoB,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;IACvD;AACF;AAEA;;CAEC,GACD,MAAM;IAUJ,YACE,KAAa,EACN,UACP,UAAkC,CAClC;wBAFO;aATO,YAAY,IAAI;aACzB,SAAS;aAIhB,WAAW,IAAI;QAOb,IAAI,CAAC,WAAW,GAAG,IAAI,0CAAkB,IAAI,EAAE,OAAO,WAAW,sCAAgB;QACjF,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,WAAW;IACjE;IAEA,QAAQ;QACN,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,WAAa;QACrC,IAAI,CAAC,SAAS,CAAC,KAAK;IACtB;AACF;AAQO,MAAM;IAOX,YACS,UACP,KAAQ,EACR,MAAqC,EACrC,UAAsB,EACtB,UAAkC,CAClC;wBALO;QAMP,IAAI,CAAC,UAAU,GACb,cACA,QAAQ,WAAW,QAAQ,CAAC,GAAG,CAAC,eAChC,oCAAc,GAAG,CAAC,UAClB,IAAI,iCAAW,QAAQ,YAAY,YAAY;QAEjD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,cAAc,CAAC,IAAI;QAC/D,2CAAqB,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI;QAC9C,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI;IACxC;IAEA,IAAI,QAAW;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK;IAC9B;IAEA,kBAAkB,UAAsB,EAAE;QACxC,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,MAAM,WAAW,IAAI,CAAC,QAAQ;QAE9B,IAAI,eAAe,WAAW,iBAAiB,CAAC,GAAG,CAAC;QACpD,IAAI,CAAC,cAAc,WAAW,iBAAiB,CAAC,GAAG,CAAC,YAAa,eAAe,IAAI;QAEpF,IAAI,cAAc,aAAa,GAAG,CAAC;QACnC,mGAAmG;QACnG,MAAM,8BAA8B,aAAa,SAAS;QAC1D,IAAI,CAAC,aAAa,aAAa,GAAG,CAAC,UAAW,cAAc,IAAI;QAEhE;;;;KAIC,GACD,IAAI,wCACF;YAAA,IAAI,CAAC,6BAA6B,YAAY,GAAG,CAAC;QAAiB,OAEnE;;;OAGC,GACD,YAAY,KAAK;QAGnB,SAAS,SAAS,CAAC,GAAG,CAAC,IAAM,aAAc,MAAM,CAAC;IACpD;IAqBA,kBACE,UAAsB,EACtB,UAAc,EACd,mBAA6B,EACd;QACf,oEAAoE;QACpE,IAAI,OAAO,eAAe,YAAY,OAAO,WAAW,IAAI,CAAC,IAAI,CAAC,UAAU;QAE5E,MAAM,WAAW,IAAI,CAAC,QAAQ;QAE9B,iFAAiF;QACjF,IACE,cACA,CAAC,CAAA,GAAA,yCAAK,AAAD,EAAE,eACP,0CAAoB,GAAG,CAAC,WAAW,WAAW,GAC9C;YACA,IAAI,WACF,eAAe,uCACX,IAAI,GACJ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAa,EAAE,iCAAiC;YAC9G,sDAAsD;YACtD,IAAI,YAAY,CAAC,SAAS,UAAU,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,WAAW;YAC7E,IAAI,CAAC,UAAU;gBACb,WAAW,IAAI,0CAAkB,IAAI,CAAC,QAAQ,EAAE,YAAY,IAAI,EAAE,YAAY;gBAC9E,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,UAAU,EAAE;YAClD,CAAC;YAED,IACE,SAAS,MAAM,CAAC,MAAM,IACrB,CAAA,0CAAoB,SAAS,MAAM,CAAC,aAAa,IAAI,mBAAkB,GAExE,IAAI,CAAC,iBAAiB,CAAC;YAEzB,OAAO,SAAS,UAAU;QAC5B,CAAC;QAED,8FAA8F;QAC9F,IAAI,SAAS,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC;QACnD,OAAO;IACT;IAEA,iBACE,eAA2B,EAC3B,KAAe,EACf,MAAiC,EACjC;QACA,MAAM,WAAW,IAAI,CAAC,QAAQ;QAC9B,MAAM,aAAa,IAAI,CAAC,UAAU;QAElC,uDAAuD;QACvD,MAAM,gBAAgB,WAAW,QAAQ,CAAC,GAAG,CAAC;QAC9C,IAAI,eAAe;YACjB,IAAI,CAAC,SAAS,OAAO,UAAU,UAC7B,wGAAwG;YACxG,6CAA6C;YAC7C,cAAc,MAAM,EAAE,SAAS,MAAM,CAAC;iBACjC,IAAI,cAAc,KAAK,KAAK,OAAO;gBACxC,8FAA8F;gBAC9F,0EAA0E;gBAC1E,cAAc,KAAK,GAAG;gBACtB,cAAc,aAAa,GAAG,IAAI;YACpC,CAAC;QACH,CAAC;QAED,8CAA8C;QAC9C,IAAI,SAAS,MAAM,CAAC,KAAK,IAAI,WAAW,MAAM,EAAE;YAC9C,WAAW,KAAK,GAAG,WAAW,OAAO,GAAG,WAAW,CAAC,WAAW,KAAK;YACpE,WAAW,aAAa,GAAG,IAAI;QACjC,CAAC;QAED,0DAA0D;QAC1D,WAAW,iBAAiB,CAAC,GAAG,CAAC,kBAAkB,QAAQ,CAAC,aAAa,WAAa;YACpF,IAAI,iBAAiB,IAAI;YACzB,IAAI,YAAY,IAAI,EAAE;gBACpB,iBAAiB,KAAK;gBACtB,KAAK,MAAM,cAAc,YAAa;oBACpC,yCAAmB;oBACnB,MAAM,WAAW,WAAW,QAAQ;oBACpC,iBACE,kBAAkB,CAAC,AAAC,CAAA,WAAW,OAAO,IAAI,OAAO,EAAE,AAAD,EAAG,UAAU,WAAW,SAAS;oBACrF,WAAW,SAAS,GAAG;oBACvB,yCAAmB;gBACrB;YACF,CAAC;YACD,IAAI,SAAS,MAAM,CAAC,OAAO,IAAI,gBAC7B,SAAS,QAAQ,GAAG,QAAQ,CAAC,EAAE,CAAC,KAAK,IAAI,WAAW,KAAK,EAAE,QAAQ,CAAC,EAAE,IAAI;QAC9E;QAEA,qDAAqD;QACrD,WAAW,MAAM,EACb,UACD,YAAY,CAAC,WAAW,MAAM,CAAC,KAAK,EAAE,WAAW,UAAU,EAAE,WAAW,KAAK;QAEhF,wDAAwD;QACxD,IAAI,IAAI,CAAC,MAAM,EACb,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAC1B,WAAW,UAAU,EACrB,WAAW,KAAK,EAChB,UAAU;YAAC;YAAY;SAAgB;aAEtC,IAAI,oBAAoB,sCAC3B,IAAI,CAAC,gBAAgB,CACnB,sCACA,WAAW,KAAK,EAChB,UAAU;YAAC;YAAY;SAAgB;IAE7C;IAEA,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM;IAC1D;AACF;AAMO,MAAM,4CAAsB,IAAI;AAoChC,SAAS,yCAAe,GAAG,IAAS,EAAE;IAC3C,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO,2CAAqB,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;SAC9D,OAAO,6CAAuB,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;AAC9D;AAEA,SAAS,2CAA2C,IAAW,EAAE,EAAY,EAAS;IACpF,4GAA4G;IAC5G,wEAAwE;IACxE,MAAM,MAAM,2CAAqB,GAAG,CAAC;IACrC,MAAM,WAAW,IAAI,+BAAS,yCAAO,MAAM,KAAK,GAAG,IAAI,KAAK;IAC5D,OAAO,SAAS,WAAW,CAAC,UAAU;AACxC;AAEA,SAAS,6CACP,IAAW,EACX,QAAyC,EACzC,MAAsF,EACtF,UAA4C,OAAO,EAAE,EAC9C;IACP,MAAM,QAAe,2CAAqB,MAAM,CAAC,OAAO,kBACtD,OAAO,SAAS,QAAQ,OAAO;IAEjC,0CAAO,IAAM,SAAS,QAAQ;IAC9B,0CAAU,OAAO;QAAE,QAAQ,KAAK;IAAC;IACjC,OAAO;AACT;AAUA,IAAI;AAEG,SAAS,0CACd,QAA6B,EAC7B,OAAyC,EAC1B;IACf,IAAI,wCAAkB,OAAO;IAC7B,yCAAmB;QAAE,UAAU;iBAAU;IAAQ;IACjD,MAAM,QAAS,uCAAiB,SAAS,GAAG;IAC5C,yCAAmB;IACnB,OAAO;AACT;AA2BA,MAAM,sCAAgB,IAA0B,CAAA;QAC9C,QAAQ,IAAI;QACZ,OAAO,KAAK;QACZ,eAAe,KAAK;QACpB,SAAS,IAAI;IACf,CAAA;AAEO,SAAS,0CAAU,UAAkB,EAAE,OAAmC,EAAE;IACjF,MAAM,MAAM,2CAAqB,GAAG,CAAC;IACrC,IAAI,CAAC,OAAO,KAAK,SAAS,WAAW,KAAK,KACxC,MAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,WAAW,CAAC,EAAE;IACnE,OAAO,MAAM,CAAC,IAAI,QAAQ,CAAC,MAAM,EAAE;AACrC;AAEO,SAAS,0CAAM,UAAkB,EAAE;IACxC,MAAM,MAAM,2CAAqB,GAAG,CAAC;IACrC,IAAI,CAAC,OAAO,KAAK,SAAS,WAAW,KAAK,KACxC,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,WAAW,CAAC,EAAE;IAC/D,IAAI,QAAQ,CAAC,KAAK;AACpB;AAMO,SAAS,yCAAU,UAAa,EAAE,UAAU,IAAI,EAAK;IAC1D,MAAM,MAAM,2CAAqB,GAAG,CAAC;IACrC,IAAI,CAAC,KAAK,OAAO;IAEjB,IAAI,IAAI,UAAU,IAAI,CAAC,IAAI,UAAU,CAAC,aAAa,CAAC,GAAG,CAAC,MACtD,MAAM,IAAI,MAAM,CAAC,uDAAuD,CAAC,EAAE;IAE7E,2DAA2D;IAC3D,IAAI,WAAW,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,EACvC,AAAC,CAAA,IAAI,MAAM,IAAI,GAAE,EAAG,iBAAiB,CAAC,IAAI,UAAU,CAAC,UAAU,EAAE,IAAI,KAAK,EAAE,IAAI;IAElF,OAAO,IAAI,UAAU,CAAC,KAAK;AAC7B;;ADlcA;AAEO,MAAM,4CAGT;IACF,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,MACT,sHAAsH;QACtH,6IAA6I;QAC7I,IAAI,KAAK,EACT;YACE,kBAAiB;gBACf,OAAO,QAAQ,cAAc,CAAC,IAAI,KAAK;YACzC;YACA,0BAAyB,MAAM,EAAE,CAAC,EAAE;gBAClC,IAAI,iBAAiB,CAAC;gBACtB,OAAO,QAAQ,wBAAwB,CAAC,IAAI,KAAK,EAAE;YACrD;YACA,WAAU;gBACR,OAAO,QAAQ,OAAO,CAAC,IAAI,KAAK;YAClC;YACA,KAAI,CAAC,EAAE,IAAI,EAAE;gBACX,IAAI,iBAAiB,CAAC;gBACtB,OAAO,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE;YAChC;YACA,KAAI,CAAC,EAAE,IAAI,EAAE;gBACX,IAAI,SAAS,UAAU,OAAO,IAAM,IAAI,KAAK;gBAC7C,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,IAAI,KAAK;gBACpD,OAAO,IAAI,iBAAiB,CAAC,MAAM;YACrC;YACA,KAAI,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;gBAClB,MAAM,WAAW,CAAA,GAAA,wCAAM,AAAD,EAAE,OAAO,KAAK;gBACpC,MAAM,WAAW,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,IAAI,KAAK;gBACvD,IAAI,aAAa,UAAU,OAAO,IAAI;gBAEtC,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,GAAG;oBAC5B,MAAM,cAAc,IAAI,KAAK,CAAC,MAAM;oBAEpC,MAAM,YAAY,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,UAAU,IAAI,KAAK;oBAElE,IAAI,gBAAgB,IAAI,KAAK,CAAC,MAAM,EAAE,IAAI,gBAAgB,CAAC;oBAC3D,IAAI,SAAS,UAAU,IAAI,gBAAgB,CAAC,MAAM;oBAElD,OAAO;gBACT,CAAC;gBAED,MAAM,SAAS,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,UAAU,IAAI,KAAK;gBAC/D,IAAI,gBAAgB,CAAC,MAAM;gBAC3B,OAAO;YACT;YACA,gBAAe,CAAC,EAAE,IAAI,EAAW;gBAC/B,MAAM,MAAM,QAAQ,cAAc,CAAC,IAAI,KAAK,EAAE;gBAC9C,IAAI,KAAK,IAAI,gBAAgB,CAAC;gBAC9B,OAAO;YACT;QACF;IAEJ;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,KAAK,CAAC,WAAW,GAAG;IACtB;IACA,aAAY,KAAU,EAAE;QACtB,IAAI,MAAM,OAAO,CAAC,QAAQ,OAAO;eAAI;SAAM;QAC3C,MAAM,QAAQ;YAAE,GAAG,KAAK;QAAC;QACzB,OAAO,cAAc,CAAC,OAAO,OAAO,cAAc,CAAC;QACnD,OAAO;IACT;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,QAAQ;AAChC,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,OAAO;;ADvE/B;AIAA;AAEA,MAAM,8BAAQ,OAAO;AAErB,MAAM,4CAAyB;IAC7B,YAAoB,IAAgC;QAClD,KAAK;mBADa;IAEpB;IAEA,IAAY,MAAc;QACxB,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK;IACvB;IAEA,IAAI,KAAQ,EAAQ;QAClB,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;QACb,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACtD,OAAO,IAAI;IACb;IAEA,QAAc;QACZ,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,KAAK;QACd,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACxD;IAEA,OAAO,KAAQ,EAAW;QACxB,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;QAC5B,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACnC,OAAO;IACT;IAEA,QAAQ,UAAoD,EAAE,OAAa,EAAQ;QACjF,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,OAAS;YAChC,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO;YACrD,WAAW,IAAI,CAAC,SAAS,YAAY,YAAY,IAAI;QACvD,GAAG;QACE,IAAI,CAAC,IAAI;IAChB;IAEA,IAAI,KAAQ,EAAW;QACrB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,OAAe;QACjB,OAAO,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,6BAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACxD;IAEA,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAwB;QACxC,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,KAAK,MAAM,SAAS,IAAI,CAAC,GAAG,CAC1B,MAAM,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO;IAE5C;IAEA,CAAC,UAAoC;QACnC,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,QAAQ,CAAC,GACvC,MAAM;YAAC;YAAO;SAAM;IAExB;IAEA,OAA4B;QAC1B,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;IAEA,SAA8B;QAC5B,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,KAAK;IAC3B,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,oCAAc;IAC3B;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,MAAM,MAAM,CAAC;QACb,MAAM,GAAG,CAAC;IACZ;IACA,aAAY,KAAK,EAAE;QACjB,OAAO,IAAI,IAAI;IACjB;AACF;;;AClFA;AAEA,MAAM,8BAAQ,OAAO;AAEd,MAAM,kDAA4B;IACvC,YAAoB,IAAmC;QACrD,KAAK;mBADa;IAEpB;IAEA,IAAY,MAAiB;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK;IACvB;IAEA,QAAc;QACZ,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,KAAK;QACd,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACxD;IAEA,OAAO,GAAM,EAAW;QACtB,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;QAC5B,IAAI,KAAK;YACP,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;YAC1B,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QAC5B,CAAC;QACD,OAAO;IACT;IAEA,QAAQ,UAAsD,EAAE,OAAa,EAAQ;QACnF,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,MAAQ;YAC/B,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,KAAK;YACnD,WAAW,IAAI,CAAC,SAAS,YAAY,KAAK,IAAI;QAChD,GAAG;QACE,IAAI,CAAC,IAAI;IAChB;IAEA,IAAI,GAAM,EAAiB;QACzB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,GAAM,EAAW;QACnB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,GAAM,EAAE,KAAQ,EAAQ;QAC1B,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK;QAClB,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YAC1B,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,KAAK;YAC/B,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QAC5B,CAAC;QACD,OAAO,IAAI;IACb;IAEA,IAAI,OAAe;QACjB,OAAO,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,6BAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI;IAC9D;IAEA,+CAA+C,GAC/C,CAAC,CAAC,OAAO,QAAQ,CAAC,GAA6B;QAC7C,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,GAAG,CAAE;YACnC,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,KAAK;YACnD,MAAM;gBAAC;gBAAK;aAAW;QACzB;IACF;IAEA,UAAoC;QAClC,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;IAEA,OAA4B;QAC1B,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACtB;IAEA,CAAC,SAA8B;QAC7B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,OAAO,QAAQ,CAAC,GAC9C,MAAM;IAEV;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,KAAK;IAC3B,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,0CAAc;IAC3B;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,MAAM,MAAM,CAAC;QACb,MAAM,GAAG,CAAC,YAAY;IACxB;IACA,aAAY,KAAK,EAAE;QACjB,OAAO,IAAI,IAAI;IACjB;AACF;;;;;;AChGA;;AAUO,SAAS,0CAAkC,IAAW,EAAS;IACpE,MAAM,GAAG,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE,CAAC;IACpC,MAAM,MAAM,CAAA,GAAA,aAAM,AAAD;IACjB,IAAI,CAAC,IAAI,OAAO,EACd,IAAI,OAAO,GAAG,CAAA,GAAA,wCAAa,EAAE,MAAM,IAAM,cAAc,CAAC;IAC1D,MAAM,QAAQ,IAAI,OAAO;IAEzB,4BAA4B;IAC5B,CAAA,GAAA,yCAAK,AAAD,EAAE;IACN,CAAA,GAAA,yCAAS,AAAD,EAAE,OAAO;QAAE,OAAO,IAAI;IAAC;IAE/B,yDAAyD;IACzD,CAAA,GAAA,gBAAS,AAAD,EAAE,IAAM;QACd,CAAA,GAAA,yCAAS,AAAD,EAAE,OAAO;YAAE,QAAQ,KAAK;QAAC;IACnC;IAEA,2CAA2C;IAC3C,CAAA,GAAA,gBAAS,AAAD,EAAE,IAAM;QACd,OAAO,IAAM;YACX,CAAA,GAAA,yCAAK,AAAD,EAAE;YACN,CAAA,GAAA,yCAAS,AAAD,EAAE,OAAO;gBAAE,SAAS,KAAK;YAAC;QACpC;IACF,GAAG;QAAC;KAAM;IAEV,OAAO;AACT;AAEO,SAAS,0CACd,IAAW,EACX,QAA2C,EAC3C,MAA0C,EAChB;IAC1B,MAAM,GAAG,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE,CAAC;IAEpC,MAAM,oBAAoB,CAAA,GAAA,aAAM,AAAD;IAC/B,MAAM,QAAQ,CAAA,GAAA,aAAK,EACjB,CAAA,GAAA,wCAAc,AAAD,EACX,MACA,CAAC,QAAU;QACT,OAAQ,kBAAkB,OAAO,GAAG,SAAS;IAC/C,GACA,CAAC,IAAM;QACL,SAAS;QACT,cAAc,CAAC;IACjB,IAEF,OAAO;IAET,CAAA,GAAA,gBAAS,AAAD,EAAE,IAAM;QACd,OAAO,IAAM,CAAA,GAAA,yCAAI,EAAE;IACrB,GAAG,EAAE;IAEL,OAAO;QAAC,kBAAkB,OAAO;QAAqB;KAAM;AAC9D;;","sources":["src/index.ts","src/factories/object.ts","src/createObserver.ts","src/ref.ts","src/factories/set.ts","src/factories/map.ts","src/react.tsx"],"sourcesContent":["import \"./factories/object\";\nimport \"./factories/set\";\nimport \"./factories/map\";\n\nexport {\n  type ObservableContext,\n  createObserver,\n  unwrap,\n  observableFactories,\n  configure,\n  derive,\n  reset,\n} from \"./createObserver\";\n\nexport { ref } from './ref';\n\nexport { objectFactory } from \"./factories/object\";\n\nexport { useObserver, useObserveSelector } from \"./react\";\n","import { ObservableFactory, observableFactories, unwrap } from \"../createObserver\";\n\nexport const objectFactory: ObservableFactory<\n  Record<string | symbol, unknown>,\n  string | symbol\n> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not really relevant since we always get/set values directly on the context value object.\n      // It's important to pass the original value though, because it needs to be an array for certain internal checks (Array.isArray, for example)\n      ctx.value,\n      {\n        getPrototypeOf() {\n          return Reflect.getPrototypeOf(ctx.value);\n        },\n        getOwnPropertyDescriptor(target, p) {\n          ctx.observeIdentifier(p);\n          return Reflect.getOwnPropertyDescriptor(ctx.value, p);\n        },\n        ownKeys() {\n          return Reflect.ownKeys(ctx.value);\n        },\n        has(_, prop) {\n          ctx.observeIdentifier(prop);\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop) {\n          if (prop === \"toJSON\") return () => ctx.value;\n          const value = Reflect.get(ctx.value, prop, ctx.value);\n          return ctx.observeIdentifier(prop, value);\n        },\n        set(_, prop, value) {\n          const rawValue = unwrap(value, false);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            if (arrayLength !== ctx.value.length) ctx.modifyIdentifier(\"length\");\n            if (prop !== \"length\") ctx.modifyIdentifier(prop, rawValue);\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n          ctx.modifyIdentifier(prop, rawValue);\n          return result;\n        },\n        deleteProperty(_, prop): boolean {\n          const res = Reflect.deleteProperty(ctx.value, prop);\n          if (res) ctx.modifyIdentifier(prop);\n          return res;\n        },\n      }\n    );\n  },\n  handleChange(value, identifier, newValue) {\n    value[identifier] = newValue;\n  },\n  createClone(value: any) {\n    if (Array.isArray(value)) return [...value];\n    const clone = { ...value };\n    Object.setPrototypeOf(clone, Object.getPrototypeOf(value));\n    return clone;\n  },\n};\n\nobservableFactories.set(Object, objectFactory);\nobservableFactories.set(Array, objectFactory);\n","import { isRef } from \"./ref\";\n\n// let debugCounter = 0;\n\n/**\n * Used to look up the SharedNode for a value that is not part of any observable tree.\n */\nconst rootDataNodes = new WeakMap<object, SharedNode>();\n\nconst rootIdentifier = Symbol(\"root\");\n\ntype Identifier = unknown | typeof rootIdentifier;\n\n/**\n * Used to look up an ObserverNode for an Observable, to unwrap an Observable.\n */\nconst contextForObservable = new WeakMap<Observable, ObservableContext>();\n\n/**\n * An Observable is an object that stands in place of another value and can be observed for changes.\n * It is a Proxy or other custom object that wraps the original object and forwards all operations to it,\n * and is produced by an ObservableFactory registered with `observableFactories`.\n * Internally, we don't know the type, but it must always be an object. To the user, the type is always the same\n * as the object that it represents.\n */\ntype Observable = object;\n\ntype Callback = (value: object, identifier: Identifier) => void;\n\n/**\n * Represents a node in an observable tree. Nodes are shared by all Observers of the same object.\n * Although a SharedNode is associated with a user object, it would be more accurate to say that\n * a SharedNode represents whatever is associated with a particular child identifier on an object\n * (i.e. when `a.b = someNewValue` happens, the same SharedNode now represents `someNewValue`).\n */\nclass SharedNode {\n  // debug = debugCounter++;\n\n  public children = new Map<Identifier, SharedNode>();\n\n  /**\n   * Used to iterate over observers to trigger callbacks.\n   * Keys are child identifiers being observed.\n   * Each value is a Map; keys are the observers and the value is a Set of Derivatives.\n   * An empty set indicates that the child is being observed without a derive function, and the\n   * observer's callback should be called for any change.\n   * A populated Set indicates that the child is being observed with derivatives, and the observer's\n   * callback should only be called if at least one of the derivatives returns a value different from\n   * its previous invocation.\n   */\n  public readonly observersForChild = new Map<Identifier, Map<Observer, Set<Derivative>>>();\n\n  /**\n   * Used to determine whether an ObserverNode for this SharedNode is still valid.\n   */\n  public validContexts = new WeakSet<ObservableContext>();\n\n  constructor(\n    public parent: SharedNode | undefined,\n    public identifier: Identifier,\n    public value: object\n  ) {\n    if (!observableFactories.has(value.constructor as any))\n      throw new Error(`Value \"${value}\" is not observable`);\n\n    if (!parent) rootDataNodes.set(value, this);\n    else parent.children.set(identifier, this);\n  }\n\n  public factory() {\n    return observableFactories.get(this.value.constructor as any)!;\n  }\n}\n\n/**\n * An Observer represents a callback that is called when a change occurs to the selected properties of its value.\n */\nclass Observer {\n  // debug = debugCounter++;\n\n  public readonly disposers = new Set<() => void>();\n  public config = defaultConfig();\n\n  public rootContext: ObservableContext;\n\n  contexts = new WeakMap<SharedNode, ObservableContext>();\n\n  constructor(\n    value: object,\n    public callback: Callback | undefined,\n    sharedNode: SharedNode | undefined\n  ) {\n    this.rootContext = new ObservableContext(this, value, undefined, rootIdentifier, sharedNode);\n    this.contexts.set(this.rootContext.sharedNode, this.rootContext);\n  }\n\n  reset() {\n    this.config = defaultConfig();\n    this.disposers.forEach((disposer) => disposer());\n    this.disposers.clear();\n  }\n}\n\n/**\n * An ObserverNode is a wrapper object that contains an observable and additional information about it.\n * Since an Observable is just a proxy for a user value, and has an unknown opaque type, additional data about it\n * is stored in this wrapper object. Every Observer has an ObserverNode object for each SharedNode that it\n * observes.\n */\nexport class ObservableContext<T extends object = object> {\n  // debug = debugCounter++;\n\n  public observable: Observable;\n\n  public sharedNode: SharedNode;\n\n  constructor(\n    public observer: Observer,\n    value: T,\n    parent: ObservableContext | undefined,\n    identifier: Identifier,\n    sharedNode: SharedNode | undefined\n  ) {\n    this.sharedNode =\n      sharedNode ||\n      parent?.sharedNode.children.get(identifier) ||\n      rootDataNodes.get(value) ||\n      new SharedNode(parent?.sharedNode, identifier, value);\n\n    this.observable = this.sharedNode.factory().makeObservable(this);\n    contextForObservable.set(this.observable, this);\n    this.sharedNode.validContexts.add(this);\n  }\n\n  get value(): T {\n    return this.sharedNode.value as T;\n  }\n\n  createObservation(identifier: Identifier) {\n    const sharedNode = this.sharedNode;\n    const observer = this.observer;\n\n    let observations = sharedNode.observersForChild.get(identifier);\n    if (!observations) sharedNode.observersForChild.set(identifier, (observations = new Map()));\n\n    let derivatives = observations.get(observer);\n    // An unconditional observation (an observation with no derivatives) is represented by an empty set\n    const hasUnconditionalObservation = derivatives?.size === 0;\n    if (!derivatives) observations.set(observer, (derivatives = new Set()));\n\n    /**\n     * Since non-derived observations override derived observations (i.e. they always\n     * cause the callback to be invoked), we don't need to track any derivatives if there is already\n     * a non-derived observation.\n     */\n    if (activeDerivative) {\n      if (!hasUnconditionalObservation) derivatives.add(activeDerivative);\n    } else {\n      /**\n       * If this observation is unconditional (i.e. no derivative), clear any existing derivatives,\n       * because they are no longer needed.\n       */\n      derivatives.clear();\n    }\n\n    observer.disposers.add(() => observations!.delete(observer));\n  }\n\n  /**\n   * Called by observable proxies to observe a child identifier.\n   * Call this to indicate that a user has accessed a property of the observed value.\n   * It will only create an observation if the observer is currently selecting properties to observe.\n   *\n   * `childValue` is used to return the child value's Observable proxy. It is only necessary to pass it if its type is\n   * unknown and could be an observable value; if you know it's a primitive or otherwise un-observable value, you may\n   * omit it or pass `undefined`.\n   *\n   * `observeIntermediate` is primarily for internal usage. You may pass `true` if you always want to observe the\n   * identifier, regardless of whether it is an intermediate value. Primitives will always be observed, regardless of this value.\n   */\n  observeIdentifier(identifier: Identifier): undefined;\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue: T,\n    observeIntermediate?: boolean\n  ): T;\n\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue?: T,\n    observeIntermediate?: boolean\n  ): T | undefined {\n    // If the value is a function, just bind it to its parent and return\n    if (typeof childValue === \"function\") return childValue.bind(this.observable);\n\n    const observer = this.observer;\n\n    // If the value is something we know how to observe, return the observable for it\n    if (\n      childValue &&\n      !isRef(childValue) &&\n      observableFactories.has(childValue.constructor as any)\n    ) {\n      let childCtx =\n        identifier === rootIdentifier\n          ? this\n          : this.observer.contexts.get(this.sharedNode.children.get(identifier)!); // this.children.get(identifier);\n      // Check that the childCtx is present in validContexts\n      if (childCtx && !childCtx.sharedNode.validContexts.has(childCtx)) childCtx = undefined;\n      if (!childCtx) {\n        childCtx = new ObservableContext(this.observer, childValue, this, identifier, undefined);\n        this.observer.contexts.set(childCtx.sharedNode, childCtx);\n      }\n\n      if (\n        observer.config.select &&\n        (activeDerivative || observer.config.intermediates || observeIntermediate)\n      )\n        this.createObservation(identifier);\n\n      return childCtx.observable as T;\n    }\n\n    // If it's a non-observable (i.e. a primitive or unknown object type), just observe and return\n    if (observer.config.select) this.createObservation(identifier);\n    return childValue;\n  }\n\n  modifyIdentifier(\n    childIdentifier: Identifier,\n    value?: unknown,\n    source?: [SharedNode, Identifier]\n  ) {\n    const observer = this.observer;\n    const sharedNode = this.sharedNode;\n\n    // Invalidate any existing contexts for this identifier\n    const childDataNode = sharedNode.children.get(childIdentifier);\n    if (childDataNode) {\n      if (!value || typeof value !== \"object\") {\n        // A SharedNode exists for childIdentifier, but the value is being deleted or replaced with a primitive;\n        // remove the child SharedNode from the tree.\n        childDataNode.parent?.children.delete(childIdentifier);\n      } else if (childDataNode.value !== value) {\n        // A SharedNode exists for childIdentifier, but the value is being replaced with a new object;\n        // update the child SharedNode's value and invalidate all contexts for it.\n        childDataNode.value = value;\n        childDataNode.validContexts = new WeakSet();\n      }\n    }\n\n    // Clone the value if enabled and not the root\n    if (observer.config.clone && sharedNode.parent) {\n      sharedNode.value = sharedNode.factory().createClone(sharedNode.value);\n      sharedNode.validContexts = new WeakSet();\n    }\n\n    // Trigger all Observer callbacks for the child Identifier\n    sharedNode.observersForChild.get(childIdentifier)?.forEach((derivatives, observer) => {\n      let isAnyDifferent = true;\n      if (derivatives.size) {\n        isAnyDifferent = false;\n        for (const derivative of derivatives) {\n          activeDerivative = derivative;\n          const newValue = derivative.deriveFn();\n          isAnyDifferent =\n            isAnyDifferent || !(derivative.isEqual || Object.is)(newValue, derivative.lastValue);\n          derivative.lastValue = newValue;\n          activeDerivative = undefined;\n        }\n      }\n      if (observer.config.enabled && isAnyDifferent)\n        observer.callback?.(source?.[0].value || sharedNode.value, source?.[1] || childIdentifier);\n    });\n\n    // Update the parent Observable with the cloned child\n    sharedNode.parent\n      ?.factory()\n      .handleChange(sharedNode.parent.value, sharedNode.identifier, sharedNode.value);\n\n    // Call modifyIdentifier on the parent/root ObserverNode\n    if (this.parent)\n      this.parent.modifyIdentifier(\n        sharedNode.identifier,\n        sharedNode.value,\n        source || [sharedNode, childIdentifier]\n      );\n    else if (childIdentifier !== rootIdentifier)\n      this.modifyIdentifier(\n        rootIdentifier,\n        sharedNode.value,\n        source || [sharedNode, childIdentifier]\n      );\n  }\n\n  get parent() {\n    return this.observer.contexts.get(this.sharedNode.parent!);\n  }\n}\n\n/**\n * The map of object prototypes to their observable factories. Implement an `ObservableFactory` and\n * add it to this map to add support for custom classes.\n */\nexport const observableFactories = new Map<\n  new (...args: any[]) => any,\n  ObservableFactory<any, any>\n>();\n\n/**\n * This interface is used to create observable objects. To create an observable for a class,\n * implement this interface and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue extends object, TIdentifier = unknown> {\n  /**\n   * Return an Observable object that stands in place of the original value.\n   */\n  makeObservable: (context: ObservableContext<TValue>) => Observable;\n\n  /**\n   * Update the `value` object with the change specified by `identifier` and `newValue`.\n   * An example of a change for a plain object would be `value[identifier] = newValue`.\n   */\n  handleChange(value: TValue, identifier: TIdentifier, newValue: unknown): void;\n\n  /**\n   * Return a shallow clone of `value`.\n   */\n  createClone(value: TValue): object;\n}\n\nexport function createObserver<TData extends object>(value: TData, cb: Callback): TData;\n\nexport function createObserver<TData extends object, TDerivedResult>(\n  data: TData,\n  deriveFn: (data: TData) => TDerivedResult,\n  action: (derivedValue: TDerivedResult, value: TData, identifier: Identifier) => void,\n  compare?: EqualityComparer<TDerivedResult>\n): TData;\n\nexport function createObserver(...args: any) {\n  if (args.length === 2) return createSimpleObserver(args[0], args[1]);\n  else return createdDerivedObserver(args[0], args[1], args[2]);\n}\n\nfunction createSimpleObserver<TData extends object>(data: TData, cb: Callback): TData {\n  // Get an existing context and SharedNode, if possible. This happens when an observable from another tree is\n  // passed to observe(). Otherwise, it will create a new root SharedNode.\n  const ctx = contextForObservable.get(data);\n  const observer = new Observer(unwrap(data, false), cb, ctx?.sharedNode);\n  return observer.rootContext.observable as TData;\n}\n\nfunction createdDerivedObserver<TData extends object, TDerivedResult>(\n  data: TData,\n  deriveFn: (data: TData) => TDerivedResult,\n  action: (derivedResult: TDerivedResult, value: object, identifier: Identifier) => void,\n  compare: EqualityComparer<TDerivedResult> = Object.is\n): TData {\n  const state: TData = createSimpleObserver(data, (value, childIdentifier) =>\n    action(deriveFn(state), value, childIdentifier)\n  );\n  derive(() => deriveFn(state), compare);\n  configure(state, { select: false });\n  return state;\n}\n\ntype EqualityComparer<T> = (a: T, b: T) => boolean;\n\ninterface Derivative {\n  lastValue?: any;\n  deriveFn: () => any;\n  isEqual?: EqualityComparer<any>;\n}\n\nlet activeDerivative: Derivative | undefined;\n\nexport function derive<TDeriveResult>(\n  deriveFn: () => TDeriveResult,\n  isEqual?: EqualityComparer<TDeriveResult>\n): TDeriveResult {\n  if (activeDerivative) return deriveFn();\n  activeDerivative = { deriveFn: deriveFn, isEqual };\n  const value = (activeDerivative.lastValue = deriveFn());\n  activeDerivative = undefined;\n  return value;\n}\n\ninterface KeckConfiguration {\n  /**\n   * When true, any accessed properties will create observations on those properties.\n   * Default is true.\n   */\n  select: boolean;\n\n  /**\n   * Indicates whether to clone ancestor values when a child value is modified. Default is false.\n   */\n  clone: boolean;\n\n  /**\n   * Indicates whether accessing intermediate properties should create an observation.\n   * Default is false.\n   */\n  intermediates: boolean;\n\n  /**\n   * Indicates whether the observer callback should be called on modifications to selected properties.\n   * Default is true.\n   */\n  enabled: boolean;\n}\n\nconst defaultConfig = (): KeckConfiguration => ({\n  select: true,\n  clone: false,\n  intermediates: false,\n  enabled: true,\n});\n\nexport function configure(observable: object, options: Partial<KeckConfiguration>) {\n  const ctx = contextForObservable.get(observable);\n  if (!ctx || ctx?.observer.rootContext !== ctx)\n    throw new Error(`Cannot configure non-observable ${observable}`);\n  Object.assign(ctx.observer.config, options);\n}\n\nexport function reset(observable: object) {\n  const ctx = contextForObservable.get(observable);\n  if (!ctx || ctx?.observer.rootContext !== ctx)\n    throw new Error(`Cannot reset non-observable ${observable}`);\n  ctx.observer.reset();\n}\n\n/**\n * \"Unwraps\" a value to give you the original object instead of the observable proxy. If `observable` is\n * not actually an observable, it will simply be returned as-is.\n */\nexport function unwrap<T>(observable: T, observe = true): T {\n  const ctx = contextForObservable.get(observable as Observable);\n  if (!ctx) return observable;\n\n  if (ctx.sharedNode && !ctx.sharedNode.validContexts.has(ctx))\n    throw new Error(`You are using a stale reference to an observable value.`);\n\n  // Unwrapping can only create an observation in select mode\n  if (observe && ctx.observer.config.select) {\n    (ctx.parent || ctx).observeIdentifier(ctx.sharedNode.identifier, ctx.value, true);\n  }\n  return ctx.sharedNode.value as T;\n}\n","import { observableFactories } from \"./createObserver\";\n\nconst _ref = Symbol('ref');\n\nexport function ref<T>(value: T): T {\n  const factory = value && observableFactories.get(value.constructor as any);\n  if (!factory) return value;\n  (value as any)[_ref] = true;\n  return value;\n}\n\nexport function isRef<T>(value: T): boolean {\n  return !!(value as any)?.[_ref];\n}\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../createObserver\";\n\nconst _size = Symbol(\"size\");\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: ObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(callbackFn: (value: T, _key: T, set: Set<T>) => void, thisArg?: any): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): IterableIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n}\n\nobservableFactories.set(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.add(newValue);\n  },\n  createClone(value) {\n    return new Set(value);\n  },\n} as ObservableFactory<Set<unknown>, any>);\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../createObserver\";\n\nconst _size = Symbol(\"size\");\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: ObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    this.ctx.observeIdentifier(key);\n    return this.map.get(key);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    this.map.set(key, value);\n    if (size !== this.map.size) {\n      this.ctx.modifyIdentifier(key, value);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.ctx.value.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const [key, value] of this.map) {\n      const observable = this.ctx.observeIdentifier(key, value);\n      yield [key, observable];\n    }\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): IterableIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [key, value] of this[Symbol.iterator]()) {\n      yield value;\n    }\n  }\n}\n\nobservableFactories.set(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.set(identifier, newValue);\n  },\n  createClone(value) {\n    return new Map(value);\n  },\n} as ObservableFactory<Map<unknown, unknown>, any>);\n","import React, {\n  useState,\n  useRef,\n  useLayoutEffect,\n  useEffect,\n  useInsertionEffect,\n  useMemo,\n} from \"react\";\nimport { configure, createObserver, reset } from \"./\";\n\nexport function useObserver<TData extends object>(data: TData): TData {\n  const [, forceRerender] = useState({});\n  const ref = useRef<TData>();\n  if (!ref.current)\n    ref.current = createObserver(data, () => forceRerender({}));\n  const state = ref.current;\n\n  // Begin observing on render\n  reset(state);\n  configure(state, { clone: true });\n\n  // Stop observing as soon as component finishes rendering\n  useEffect(() => {\n    configure(state, { select: false });\n  });\n\n  // Disable callback when component unmounts\n  useEffect(() => {\n    return () => {\n      reset(state);\n      configure(state, { enabled: false });\n    };\n  }, [state]);\n\n  return state;\n}\n\nexport function useObserveSelector<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (state: TData) => TSelectorResult,\n  action?: (result: TSelectorResult) => void\n): [TSelectorResult, TData] {\n  const [, forceRerender] = useState({});\n\n  const selectorResultRef = useRef<TSelectorResult>();\n  const state = useRef(\n    createObserver(\n      data,\n      (state) => {\n        return (selectorResultRef.current = selector(state));\n      },\n      (v) => {\n        action?.(v);\n        forceRerender({});\n      }\n    )\n  ).current;\n\n  useEffect(() => {\n    return () => reset(state);\n  }, []);\n\n  return [selectorResultRef.current as TSelectorResult, state];\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}