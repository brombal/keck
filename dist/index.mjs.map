{"mappings":"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","sources":["src/index.ts","src/observables/object-array.ts","src/observe.ts","src/ref.ts","src/observables/set.ts","src/observables/map.ts","src/react.tsx"],"sourcesContent":["import \"./observables/object-array\";\nimport \"./observables/set\";\nimport \"./observables/map\";\n\nexport {\n  type ObservableContext,\n  observe,\n  unwrap,\n  observableFactories,\n  configure,\n  select,\n  reset,\n} from \"./observe\";\n\nexport { ref } from './ref';\n\nexport { objectAndArrayObservableFactory } from \"./observables/object-array\";\n\nexport { useObserver, useObserveSelector } from \"./react\";\n","import { ObservableFactory, observableFactories, unwrap } from \"../observe\";\n\nexport const objectAndArrayObservableFactory: ObservableFactory<\n  Record<string | symbol, unknown>,\n  string | symbol\n> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not really relevant since we always get/set values directly on the context value object.\n      // It's important to pass the original value though, because it needs to be an array for certain internal checks (Array.isArray, for example)\n      ctx.value,\n      {\n        getPrototypeOf() {\n          return Reflect.getPrototypeOf(ctx.value);\n        },\n        getOwnPropertyDescriptor(target, p) {\n          ctx.observeIdentifier(p);\n          return Reflect.getOwnPropertyDescriptor(ctx.value, p);\n        },\n        ownKeys() {\n          return Reflect.ownKeys(ctx.value);\n        },\n        has(_, prop) {\n          ctx.observeIdentifier(prop);\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop) {\n          if (prop === \"toJSON\") return () => ctx.value;\n          const value = Reflect.get(ctx.value, prop, ctx.value);\n          return ctx.observeIdentifier(prop, value);\n        },\n        set(_, prop, value) {\n          const rawValue = unwrap(value, false);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            if (arrayLength !== ctx.value.length) ctx.modifyIdentifier(\"length\");\n            if (prop !== \"length\") ctx.modifyIdentifier(prop);\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n          ctx.modifyIdentifier(prop);\n          return result;\n        },\n        deleteProperty(_, prop): boolean {\n          const res = Reflect.deleteProperty(ctx.value, prop);\n          if (res) ctx.modifyIdentifier(prop);\n          return res;\n        },\n      }\n    );\n  },\n  handleChange(value, identifier, newValue) {\n    value[identifier] = newValue;\n  },\n  createClone(value: any) {\n    if (Array.isArray(value)) return [...value];\n    const clone = { ...value };\n    Object.setPrototypeOf(clone, Object.getPrototypeOf(value));\n    return clone;\n  },\n};\n\nobservableFactories.set(Object, objectAndArrayObservableFactory);\nobservableFactories.set(Array, objectAndArrayObservableFactory);\n","import { isRef } from \"./ref\";\n\n/**\n * Represents a node in an observable tree. Nodes are shared by all Observers of the same object.\n */\ninterface DataNode {\n  identifier: Identifier;\n  value: object;\n  factory: ObservableFactory<object>;\n  parent: DataNode | undefined;\n  children: Map<Identifier, DataNode>;\n\n  /**\n   * Used to iterate over observers to trigger callbacks.\n   * Keys are child identifiers being observed.\n   * Each value is a Map; keys are the observers and the value is a Set of Selectors.\n   * An empty set indicates that the child is being observed without a selector function, and the\n   * observer's callback should be called for any change.\n   * A populated Set indicates that the child is being observed with selectors and the observer's\n   * callback should only be called if at least one of the selectors returns a value different from\n   * its previous invocation.\n   */\n  observersForChild: Map<Identifier, Map<Observer<object>, Set<Selector>>>;\n\n  // Used to determine whether an ObservableContext is still valid\n  validContexts: WeakSet<ObservableContext<object>>;\n}\n\ninterface Observer<T extends object> {\n  config: KeckConfiguration;\n  callback: Callback | undefined;\n  disposers: Set<() => void>;\n\n  // Used to look up existing ObservableContext for a given DataNode (necessary for maintaining ref equality of observables)\n  contextForNode: WeakMap<DataNode, ObservableContext<object>>;\n}\n\nconst rootIdentifier = Symbol(\"root\");\n\ntype Identifier = unknown | typeof rootIdentifier;\n\n/**\n * Allows looking up an Observable's ObservableContext, so that it can be unwrapped\n */\nconst contextForObservable = new WeakMap<Observable, ObservableContext<object>>();\n\nexport interface ObservableContext<TValue extends object> {\n  root: boolean;\n  dataNode: DataNode;\n  observer: Observer<TValue>;\n  observable: Observable;\n\n  readonly value: TValue;\n\n  /**\n   * Observe a child identifier. Call this to indicate that a user has accessed a property of the observed value. It\n   * will only create an observation if the observer is currently configured to observe.\n   *\n   * `childValue` is mapped to its observable version and returned. It is only necessary to pass it if its type is\n   * unknown and could be an observable value; if you know it's a primitive or otherwise un-observable value, you may\n   * omit it or pass `undefined`.\n   *\n   * `observeIntermediate` is primarily for internal usage. You may pass `true` if you always want to observe the\n   * identifier, regardless of whether it is an intermediate value. Primitives will always be observed, regardless of this value.\n   */\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue?: T,\n    observeIntermediate?: boolean\n  ): T;\n\n  modifyIdentifier(childIdentifier: Identifier, source?: [DataNode, Identifier]): void;\n}\n\ntype Observable = object;\n\ntype Callback = (value: object, identifier: Identifier) => void;\n\n/**\n * The map of object prototypes to their observable factories. Implement an `ObservableFactory` and\n * add it to this map to add support for custom classes.\n */\nexport const observableFactories = new Map<\n  new (...args: any[]) => any,\n  ObservableFactory<any, any>\n>();\n\n/**\n * This interface is used to create observable objects. To create an observable for a class,\n * implement this interface and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue extends object, TIdentifier = unknown> {\n  /**\n   * Returns an object that stands in place of the original value, and can be observed.\n   */\n  makeObservable: (context: ObservableContext<TValue>) => Observable;\n\n  /**\n   * Applies a change to `value` for the given `identifier`.\n   * An example of a change for a plain object would be `value[identifier] = newValue`.\n   */\n  handleChange(value: TValue, identifier: TIdentifier, newValue: unknown): void;\n\n  /**\n   * Returns a clone of `value`.\n   */\n  createClone(value: TValue): object;\n}\n\nconst allDataNodes = new WeakMap<object, DataNode>();\n\nfunction getDataNode(\n  identifier: Identifier,\n  value: object,\n  parent?: DataNode\n): DataNode | undefined {\n  const factory = observableFactories.get(value.constructor as any);\n  if (!factory) return undefined;\n\n  let dataNode = parent ? parent.children.get(identifier) : allDataNodes.get(value);\n  if (dataNode) {\n    dataNode.value = value;\n    return dataNode;\n  }\n\n  dataNode = {\n    identifier,\n    value,\n    children: new Map(),\n    parent,\n    factory,\n    observersForChild: new Map(),\n    validContexts: new WeakSet(),\n  };\n  if (parent) parent.children.set(identifier, dataNode);\n  allDataNodes.set(value, dataNode);\n  return dataNode;\n}\n\nfunction createObservation(identifier: Identifier, dataNode: DataNode, observer: Observer<object>) {\n  let observations = dataNode.observersForChild.get(identifier);\n  if (!observations) dataNode.observersForChild.set(identifier, (observations = new Map()));\n\n  let selectors = observations.get(observer);\n  // A non-selector observation is represented by an empty set\n  const hasNonSelectorObservation = selectors && selectors.size === 0;\n  if (!selectors) observations.set(observer, (selectors = new Set()));\n\n  /**\n   * Since non-selector observations override selector observations (i.e. they always\n   * cause the callback to be invoked), we don't need to track any selectors if there is already\n   * a non-selector observation.\n   */\n  if (activeSelector) {\n    if (!hasNonSelectorObservation) selectors.add(activeSelector);\n  } else {\n    selectors.clear();\n  }\n\n  observer.disposers.add(() => observations!.delete(observer));\n}\n\nfunction getObservableContext(\n  observer: Observer<object>,\n  dataNode: DataNode\n): ObservableContext<object> {\n  let ctx = observer.contextForNode.get(dataNode);\n\n  // Check that the context is still valid\n  if (ctx && !dataNode.validContexts.has(ctx)) {\n    ctx = undefined;\n    observer.contextForNode.delete(dataNode);\n  }\n  if (ctx) return ctx;\n\n  ctx = {\n    root: false,\n    dataNode,\n    observer,\n    observable: null!,\n    get value() {\n      return this.dataNode.value;\n    },\n    observeIdentifier(identifier, childValue, observeIntermediate = false) {\n      // If the value is a function, just bind it to its parent and return\n      if (typeof childValue === \"function\") return childValue.bind(this.observable);\n\n      // If the property is something we know how to observe, return the observable value\n      const childNode = childValue && !isRef(childValue) && getDataNode(identifier, childValue, dataNode);\n      if (childNode) {\n        if (\n          observer.config.observe &&\n          (activeSelector || observer.config.intermediates || observeIntermediate)\n        )\n          createObservation(identifier, dataNode, observer);\n        return getObservableContext(observer, childNode).observable;\n      }\n\n      // If it's a non-observable (i.e. a primitive or unknown object type), just observe and return\n      if (observer.config.observe) createObservation(identifier, dataNode, observer);\n      return childValue;\n    },\n    modifyIdentifier(childIdentifier: Identifier, source?: [DataNode, Identifier]) {\n      // Clone the value if not the root\n      if (observer.config.clone && dataNode.parent)\n        dataNode.value = dataNode.factory.createClone(dataNode.value);\n\n      // Invalidate Observables for all ObservableContexts of the child Identifier\n      // The presence of `source` indicates that this is a recursive call, so we should not\n      // invalidate unless we are cloning\n      if ((observer.config.clone || !source) && dataNode.children.get(childIdentifier)){\n        dataNode.children.get(childIdentifier)!.validContexts = new Set();\n      }\n\n      // If this is a direct property modification, clear out all the DataNodes for its children\n      if (!source) dataNode.children.get(childIdentifier)?.children.clear();\n\n      // Trigger all Observer callbacks for the child Identifier\n      dataNode.observersForChild.get(childIdentifier)?.forEach((selectors, observer) => {\n        let isAnyDifferent: boolean | undefined = undefined;\n        if (selectors.size) {\n          isAnyDifferent = false;\n          for (const selector of selectors) {\n            activeSelector = selector;\n            const newValue = selector.selectorFn();\n            isAnyDifferent =\n              isAnyDifferent || !(selector.isEqual || Object.is)(newValue, selector.lastValue);\n            selector.lastValue = newValue;\n            activeSelector = undefined;\n          }\n        }\n        if (observer.config.enabled && (isAnyDifferent === true || isAnyDifferent === undefined))\n          observer.callback?.(source?.[0].value || dataNode.value, source?.[1] || childIdentifier);\n      });\n\n      // Let the parent Observable update itself with the cloned child\n      dataNode.parent?.factory.handleChange(\n        dataNode.parent!.value,\n        dataNode.identifier,\n        dataNode.value\n      );\n\n      // Call modifyIdentifier on the parent/root ObservableContext\n      if (childIdentifier !== rootIdentifier)\n        getObservableContext(observer, dataNode.parent || dataNode)?.modifyIdentifier(\n          dataNode.identifier,\n          source || [dataNode, childIdentifier]\n        );\n    },\n  };\n  ctx.observable = dataNode.factory.makeObservable(ctx);\n  observer.contextForNode.set(dataNode, ctx);\n  contextForObservable.set(ctx.observable, ctx);\n  dataNode.validContexts.add(ctx);\n  return ctx;\n}\n\nexport function observe<TData extends object>(value: TData, cb: Callback): TData;\n\nexport function observe<TData extends object, TSelectorResult>(\n  data: TData,\n  selectorFn: (data: TData) => TSelectorResult,\n  action: (selectedValue: TSelectorResult, value: TData, identifier: Identifier) => void,\n  compare?: EqualityComparer<TSelectorResult>\n): TData;\n\nexport function observe(...args: any) {\n  if (args.length === 2) return createObserver(args[0], args[1]);\n  else return createSelectorObserver(args[0], args[1], args[2]);\n}\n\nexport function createObserver<TData extends object>(data: TData, cb: Callback): TData {\n  // Get an existing DataNode, if possible. This happens when an observable from another tree is\n  // passed to observe().\n  const rootNode = contextForObservable.get(data)?.dataNode || getDataNode(rootIdentifier, data);\n  if (!rootNode) throw new Error(`Cannot observe value ${data}`);\n\n  const observer: Observer<TData> = {\n    callback: cb,\n    disposers: new Set(),\n    contextForNode: new WeakMap(),\n    config: defaultConfig(),\n  };\n  const ctx = getObservableContext(observer, rootNode);\n  ctx.root = true;\n\n  return ctx.observable as TData;\n}\n\nexport function createSelectorObserver<TData extends object, TSelectedResult>(\n  data: TData,\n  selectorFn: (data: TData) => TSelectedResult,\n  action: (selectedResult: TSelectedResult, value: object, identifier: Identifier) => void,\n  compare: EqualityComparer<TSelectedResult> = Object.is\n): TData {\n  const state: TData = observe(data, (value, childIdentifier) =>\n    action(selectorFn(state), value, childIdentifier)\n  );\n  select(() => selectorFn(state), compare);\n  configure(state, { observe: false });\n  return state;\n}\n\ntype EqualityComparer<T> = (a: T, b: T) => boolean;\n\ninterface Selector {\n  lastValue?: any;\n  selectorFn: () => any;\n  isEqual?: EqualityComparer<any>;\n}\n\nlet activeSelector: Selector | undefined;\n\nexport function select<TSelectorResult>(\n  selectorFn: () => TSelectorResult,\n  isEqual?: EqualityComparer<TSelectorResult>\n): TSelectorResult {\n  if (activeSelector) return selectorFn();\n  activeSelector = { selectorFn, isEqual };\n  const value = (activeSelector.lastValue = selectorFn());\n  activeSelector = undefined;\n  return value;\n}\n\ninterface KeckConfiguration {\n  observe: boolean;\n  clone: boolean;\n  intermediates: boolean;\n  enabled: boolean;\n}\n\nconst defaultConfig = (): KeckConfiguration => ({\n  observe: true,\n  clone: false,\n  intermediates: false,\n  enabled: true,\n});\n\nexport function configure(observable: object, options: Partial<KeckConfiguration>) {\n  const ctx = contextForObservable.get(observable);\n  if (!ctx?.root) throw new Error(`Cannot configure non-observable ${observable}`);\n  Object.assign(ctx.observer.config, options);\n}\n\nexport function reset(observable: object) {\n  const ctx = contextForObservable.get(observable);\n  if (!ctx?.root) throw new Error(`Cannot reset non-observable ${observable}`);\n  Object.assign(ctx.observer.config, defaultConfig());\n  ctx.observer.disposers.forEach((disposer) => disposer());\n  ctx.observer.disposers.clear();\n}\n\n/**\n * \"Unwraps\" a value to give you the original object instead of the observable proxy or subclass. If `observable` is\n * not actually an observable, it will simply be returned as-is.\n */\nexport function unwrap<T>(observable: T, observe = true): T {\n  const ctx = contextForObservable.get(observable as Observable);\n  if (!ctx) return observable;\n  // Unwrapping can only create a observation in select mode\n  if (observe && ctx.observer.config.observe) {\n    getObservableContext(ctx.observer, ctx.dataNode.parent || ctx.dataNode)?.observeIdentifier(\n      ctx.dataNode.identifier,\n      ctx.value,\n      true\n    );\n  }\n  return ctx.dataNode.value as T;\n}\n","import { observableFactories } from \"./observe\";\n\nconst _ref = Symbol('ref');\n\nexport function ref<T extends object>(value: T): T {\n  const factory = observableFactories.get(value.constructor as any);\n  if (!factory) return value;\n  (value as any)[_ref] = true;\n  return value;\n}\n\nexport function isRef<T>(value: T): boolean {\n  return !!(value as any)?.[_ref];\n}\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: ObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(callbackFn: (value: T, _key: T, set: Set<T>) => void, thisArg?: any): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): IterableIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n}\n\nobservableFactories.set(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.add(newValue);\n  },\n  createClone(value) {\n    return new Set(value);\n  },\n} as ObservableFactory<Set<unknown>, any>);\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: ObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    this.ctx.observeIdentifier(key);\n    return this.map.get(key);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    this.map.set(key, value);\n    if (size !== this.map.size) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.ctx.value.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const [key, value] of this.map) {\n      const observable = this.ctx.observeIdentifier(key, value);\n      yield [key, observable];\n    }\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): IterableIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [key, value] of this[Symbol.iterator]()) {\n      yield value;\n    }\n  }\n}\n\nobservableFactories.set(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.set(identifier, newValue);\n  },\n  createClone(value) {\n    return new Map(value);\n  },\n} as ObservableFactory<Map<unknown, unknown>, any>);\n","import React, {\n  useState,\n  useRef,\n  useLayoutEffect,\n  useEffect,\n  useInsertionEffect,\n  useMemo,\n} from \"react\";\nimport { configure, observe, reset } from \"./\";\n\nexport function useObserver<TData extends object>(data: TData): TData {\n  const [, forceRerender] = useState({});\n  const ref = useRef<TData>();\n  if (!ref.current)\n    ref.current = observe(data, () => forceRerender({}));\n  const state = ref.current;\n\n  // Begin observing on render\n  reset(state);\n  configure(state, { clone: true });\n\n  // Stop observing as soon as component finishes rendering\n  useEffect(() => {\n    configure(state, { observe: false });\n  });\n\n  // Disable callback when component unmounts\n  useEffect(() => {\n    return () => {\n      reset(state);\n      configure(state, { enabled: false });\n    };\n  }, [state]);\n\n  return state;\n}\n\nexport function useObserveSelector<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (state: TData) => TSelectorResult,\n  action?: (result: TSelectorResult) => void\n): [TSelectorResult, TData] {\n  const [, forceRerender] = useState({});\n\n  const selectorResultRef = useRef<TSelectorResult>();\n  const state = useRef(\n    observe(\n      data,\n      (state) => {\n        return (selectorResultRef.current = selector(state));\n      },\n      (v) => {\n        action?.(v);\n        forceRerender({});\n      }\n    )\n  ).current;\n\n  useEffect(() => {\n    return () => reset(state);\n  }, []);\n\n  return [selectorResultRef.current as TSelectorResult, state];\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}