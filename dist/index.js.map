{"mappings":"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","sources":["src/index.ts","src/observables/object-array.ts","src/observe.tsx","src/observables/set.ts","src/observables/map.ts","src/react.tsx"],"sourcesContent":["import \"./observables/object-array\";\nimport \"./observables/set\";\nimport \"./observables/map\";\n\nexport { type ObservableContext, observe, unwrap, observableFactories } from \"./observe\";\n\nexport { objectAndArrayObservableFactory } from \"./observables/object-array\";\n\nexport { useObserver } from \"./react\";\n","import { ObservableFactory, observableFactories, unwrap } from \"../observe\";\n\nexport const objectAndArrayObservableFactory: ObservableFactory<\n  Record<string | symbol, unknown>,\n  string | symbol\n> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not really relevant since we always get/set values directly on the context value object.\n      // It's important to pass the original value though, because it needs to be an array for certain internal checks (Array.isArray, for example)\n      ctx.value,\n      {\n        getPrototypeOf() {\n          return Reflect.getPrototypeOf(ctx.value);\n        },\n        getOwnPropertyDescriptor(target, p) {\n          ctx.observeIdentifier(p);\n          return Reflect.getOwnPropertyDescriptor(ctx.value, p);\n        },\n        ownKeys() {\n          return Reflect.ownKeys(ctx.value);\n        },\n        has(_, prop) {\n          ctx.observeIdentifier(prop);\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop) {\n          if (prop === \"toJSON\") return () => ctx.value;\n          const value = Reflect.get(ctx.value, prop, ctx.value);\n          return ctx.observeIdentifier(prop, value);\n        },\n        set(_, prop, value) {\n          const rawValue = unwrap(value);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            if (arrayLength !== ctx.value.length) ctx.modifyIdentifier(\"length\");\n            if (prop !== \"length\") ctx.modifyIdentifier(prop);\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n          ctx.modifyIdentifier(prop);\n          return result;\n        },\n        deleteProperty(_, prop): boolean {\n          const res = Reflect.deleteProperty(ctx.value, prop);\n          if (res) ctx.modifyIdentifier(prop);\n          return res;\n        },\n      }\n    );\n  },\n  handleChange(value, identifier, newValue) {\n    value[identifier] = newValue;\n  },\n  createClone(value: any) {\n    if (Array.isArray(value)) return [...value];\n    const clone = { ...value };\n    Object.setPrototypeOf(clone, Object.getPrototypeOf(value));\n    return clone;\n  },\n};\n\nobservableFactories.set(Object, objectAndArrayObservableFactory);\nobservableFactories.set(Array, objectAndArrayObservableFactory);\n","/**\n *\n *\n *\n */\n\n/**\n * Represents a node in an observable tree. Nodes are shared by all Observers of the same object.\n */\ninterface DataNode {\n  identifier: Identifier;\n  value: object;\n  factory: ObservableFactory<object>;\n  parent: DataNode | undefined;\n  children: Map<Identifier, DataNode>;\n\n  // Used to iterate over observers to trigger callbacks\n  observersForChild: Map<Identifier, Set<Observer<object>>>;\n\n  // Used to determine whether an ObservableContext is still valid\n  allContexts: WeakSet<ObservableContext<object>>;\n}\n\ninterface Observer<T extends object> {\n  isObserving: boolean;\n  callback: Callback | undefined;\n  disposers: Set<() => void>;\n\n  // Used to look up existing ObservableContext for a given DataNode (necessary for maintaining ref equality of observables)\n  contextForNode: WeakMap<DataNode, ObservableContext<object>>;\n}\n\nconst rootIdentifier = Symbol(\"root\");\n\ntype Identifier = unknown | typeof rootIdentifier;\n\n/**\n * Allows looking up an Observable's ObservableContext, so that it can be unwrapped\n */\nconst contextForObservable = new WeakMap<Observable, ObservableContext<object>>();\n\nexport interface ObservableContext<TValue extends object> {\n  dataNode: DataNode;\n  observer: Observer<TValue>;\n  observable: Observable;\n\n  readonly value: TValue;\n\n  /**\n   * Observe a child identifier. Call this to indicate that a user has accessed a property of the observed value. It\n   * will only be observed if the observer is currently enabled.\n   *\n   * `childValue` is mapped to its observable version and returned. It is only necessary to pass it if its type is\n   * unknown and could be an observable value; if you know it's a primitive or otherwise un-observable value, you may\n   * omit it or pass `undefined`.\n   *\n   * `observeIntermediate` is primarily for internal usage. You may pass `true` if you always want to observe the\n   * identifier, regardless of whether it is an intermediate value. Primitives will always be observed, regardless of this value.\n   */\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue?: T,\n    observeIntermediate?: boolean\n  ): T;\n\n  modifyIdentifier(childIdentifier: Identifier): void;\n}\n\ntype Observable = object;\n\ntype Callback = (value: object, identifier: Identifier) => void;\n\n/**\n * The map of object prototypes to their observable factories. Implement an `ObservableFactory` and add it to this map to add support\n * for custom classes.\n */\nexport const observableFactories = new Map<\n  new (...args: any[]) => any,\n  ObservableFactory<any, any>\n>();\n\n/**\n * This interface is used to create observable objects. To create an observable for a class, implement this interface\n * and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue extends object, TIdentifier = unknown> {\n  /**\n   * Returns an object that stands in place of the original value, and can be observed.\n   */\n  makeObservable: (context: ObservableContext<TValue>) => Observable;\n\n  /**\n   * Applies a change to `value` for the given `identifier`.\n   * An example of a change for a plain object would be `value[identifier] = newValue`.\n   */\n  handleChange(value: TValue, identifier: TIdentifier, newValue: unknown): void;\n\n  /**\n   * Returns a clone of `value`.\n   */\n  createClone(value: TValue): object;\n}\n\nconst rootDataNodes = new WeakMap<object, DataNode>();\n\nfunction getDataNode(\n  identifier: Identifier,\n  value: object,\n  parent?: DataNode\n): DataNode | undefined {\n  let dataNode = parent ? parent.children.get(identifier) : rootDataNodes.get(value);\n  if (dataNode) {\n    dataNode.value = value;\n    return dataNode;\n  }\n\n  const factory = observableFactories.get(value.constructor as any);\n  if (!factory) return undefined;\n\n  dataNode = {\n    identifier,\n    value,\n    children: new Map(),\n    parent,\n    factory,\n    observersForChild: new Map(),\n    allContexts: new WeakSet(),\n  };\n  if (parent) parent.children.set(identifier, dataNode);\n  else rootDataNodes.set(value, dataNode);\n  return dataNode;\n}\n\nfunction getObservableContext(\n  observer: Observer<object>,\n  dataNode: DataNode\n): ObservableContext<object> {\n  let ctx = observer.contextForNode.get(dataNode);\n\n  // Check that the context was not previously invalidated\n  if (ctx && !dataNode.allContexts.has(ctx)) {\n    ctx = undefined;\n    observer.contextForNode.delete(dataNode);\n  }\n  if (ctx) return ctx;\n\n  ctx = {\n    dataNode: dataNode,\n    observer: observer,\n    observable: null!,\n    get value() {\n      return this.dataNode.value;\n    },\n    observeIdentifier(identifier, childValue, observeIntermediate = false) {\n      // If the value is a function, bind it to its parent\n      if (typeof childValue === \"function\") {\n        return childValue.bind(this.observable);\n      }\n\n      function addObserver() {\n        if (!observer.isObserving) return;\n        let observers = dataNode.observersForChild.get(identifier);\n        if (!observers) dataNode.observersForChild.set(identifier, (observers = new Set()));\n        observers.add(observer);\n        observer.disposers.add(() => observers!.delete(observer));\n      }\n\n      if (childValue) {\n        // If the property is something we know how to observe, return the observable value\n        const childNode = getDataNode(identifier, childValue, dataNode);\n        if (childNode) {\n          if (observeIntermediate) addObserver();\n          return getObservableContext(observer, childNode).observable;\n        }\n      }\n\n      // If it's a non-observable (i.e. a primitive or unknown object type), just observe and return\n      addObserver();\n      return childValue;\n    },\n    modifyIdentifier(childIdentifier) {\n      if (dataNode.parent) {\n        // Get the factory for the new value\n        dataNode.factory = observableFactories.get(dataNode.value.constructor as any)!;\n        // Clone the value\n        dataNode.value = dataNode.factory.createClone(dataNode.value);\n      }\n\n      // Invalidate Observables for all ObservableContexts of the child Identifier\n      if (dataNode.children.get(childIdentifier))\n        dataNode.children.get(childIdentifier)!.allContexts = new Set();\n\n      // Trigger all Observer callbacks for the child Identifier\n      dataNode.observersForChild.get(childIdentifier)?.forEach((observer) => {\n        observer.callback?.(dataNode.value, childIdentifier);\n      });\n\n      // Let the parent Observable update itself with the cloned child\n      dataNode.parent?.factory.handleChange(\n        dataNode.parent!.value,\n        dataNode.identifier,\n        dataNode.value\n      );\n\n      // Call modifyIdentifier on the parent/root ObservableContext\n      if (childIdentifier !== rootIdentifier)\n        getObservableContext(observer, dataNode.parent || dataNode)?.modifyIdentifier(\n          dataNode.identifier\n        );\n    },\n  };\n  ctx.observable = dataNode.factory.makeObservable(ctx);\n  observer.contextForNode.set(dataNode, ctx);\n  contextForObservable.set(ctx.observable, ctx);\n  dataNode.allContexts.add(ctx);\n  return ctx;\n}\n\ntype ObserveResponse<T> = [\n  T,\n  {\n    /**\n     * Begins listening to property access. This is called automatically when the observer is created, but may be called\n     * again to re-enable the observer after it has been disabled.\n     */\n    start(): void;\n\n    /**\n     * Stops listening to property access.\n     */\n    stop(): void;\n\n    /**\n     * Disables the callback from being invoked on property writes.\n     */\n    disable(): void;\n\n    /**\n     * Enables the callback to be invoked on property writes.\n     */\n    enable(): void;\n\n    /**\n     * Removes all existing observations.\n     */\n    reset(): void;\n  }\n];\n\nexport function observe<TValue extends object>(\n  value: TValue,\n  cb: Callback\n): ObserveResponse<TValue>;\nexport function observe<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (data: TData) => TSelectorResult,\n  action: (selectorResult: TSelectorResult, value: TData) => void\n): [TData, () => void];\n\nexport function observe(...args: any) {\n  if (args.length === 2) return createObserver(args[0], args[1]);\n  else return createObserverSelector(args[0], args[1], args[2]);\n}\n\nexport function createObserver<TData extends object>(\n  data: TData,\n  cb: Callback\n): ObserveResponse<TData> {\n  // Get an existing context, if possible. This happens when an observable from another tree is passed to observe().\n  const ctx = contextForObservable.get(data);\n  const rootNode = ctx?.dataNode || getDataNode(rootIdentifier, data);\n  if (!rootNode) throw new Error(`Cannot observe value ${data}`);\n\n  const observer: Observer<TData> = {\n    isObserving: true,\n    callback: cb,\n    disposers: new Set(),\n    contextForNode: new WeakMap(),\n  };\n\n  const store = getObservableContext(observer, rootNode).observable as TData;\n  return [\n    store,\n    {\n      start() {\n        observer.isObserving = true;\n      },\n      stop() {\n        observer.isObserving = false;\n      },\n      disable() {\n        observer.callback = undefined;\n      },\n      enable() {\n        observer.callback = cb;\n      },\n      reset() {\n        observer.disposers.forEach((disposer) => disposer());\n        observer.disposers.clear();\n      },\n    },\n  ];\n}\n\n/**\n * Creates an observer and immediately observes the result of the selector function. The selector function is called\n * whenever the value of the observable changes, and the action callback is called whenever the result of the selector\n * function changes.\n *\n * The if the selector function returns a plain array (observables that represent arrays will work normally), it will be\n * shallow compared with the previous value to determine if the observer callback should be called.\n */\nexport function createObserverSelector<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (data: TData) => TSelectorResult,\n  action: (selectorResult: TSelectorResult, value: TData) => void\n): [TData, () => void] {\n  const [state, actions] = observe(data, () => {\n    const newSelectorResult = selector(state);\n    let isEqual = false;\n\n    let newResult: any;\n    if (Array.isArray(newSelectorResult) && !contextForObservable.has(newSelectorResult)) {\n      newResult = newSelectorResult.map((v) => unwrap(v, false));\n      isEqual =\n        prevResult.length === newResult.length &&\n        newResult.every((v: any, i: number) => prevResult[i] === v);\n    } else {\n      newResult = unwrap(newSelectorResult, false);\n      isEqual = newResult === prevResult;\n    }\n\n    if (!isEqual) action(newResult, data);\n    prevResult = newResult;\n  });\n  const selectorResult = selector(state);\n  let prevResult: any;\n\n  // If the selector returns a new, non-observable array, unwrap each element to observe it individually.\n  if (Array.isArray(selectorResult) && !contextForObservable.has(selectorResult)) {\n    prevResult = selectorResult.map((v) => unwrap(v));\n  } else {\n    prevResult = unwrap(selectorResult);\n  }\n\n  return [\n    state,\n    () => {\n      actions.stop();\n      actions.disable();\n      actions.reset();\n    },\n  ];\n}\n\nexport function unwrap<T>(observable: T, observe = true): T {\n  const ctx = contextForObservable.get(observable as Observable);\n  if (!ctx) return observable;\n  if (observe) {\n    getObservableContext(ctx.observer, ctx.dataNode.parent || ctx.dataNode)?.observeIdentifier(\n      ctx.dataNode.identifier,\n      ctx.value,\n      true\n    );\n  }\n  return ctx.dataNode.value as T;\n}\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: ObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(callbackFn: (value: T, _key: T, set: Set<T>) => void, thisArg?: any): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): IterableIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n}\n\nobservableFactories.set(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.add(newValue);\n  },\n  createClone(value) {\n    return new Set(value);\n  },\n} as ObservableFactory<Set<unknown>, any>);\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: ObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    this.ctx.observeIdentifier(key);\n    return this.map.get(key);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    this.map.set(key, value);\n    if (size !== this.map.size) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.ctx.value.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const [key, value] of this.map) {\n      const observable = this.ctx.observeIdentifier(key, value);\n      yield [key, observable];\n    }\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): IterableIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [key, value] of this[Symbol.iterator]()) {\n      yield value;\n    }\n  }\n}\n\nobservableFactories.set(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.set(identifier, newValue);\n  },\n  createClone(value) {\n    return new Map(value);\n  },\n} as ObservableFactory<Map<unknown, unknown>, any>);\n","import React, { useState, useRef, useLayoutEffect, useEffect, useInsertionEffect } from \"react\";\nimport { observe } from \"./\";\n\nexport function useObserver<T extends object>(\n  data: T\n): [T, { start: () => void; stop: () => void }] {\n  const [, forceRerender] = useState({});\n  const [store, { reset, start, stop }] = useRef(observe(data, () => forceRerender({}))).current;\n\n  // Begin observing on render\n  reset();\n  start();\n\n  // Stop observing as soon as component finishes rendering\n  useEffect(() => {\n    stop();\n  });\n\n  // Disable callback when component unmounts\n  useLayoutEffect(() => {\n    return () => reset();\n  }, []);\n\n  return [store, { start, stop }];\n}\n"],"names":[],"version":3,"file":"index.js.map"}