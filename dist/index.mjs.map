{"mappings":"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","sources":["src/index.ts","src/observables/object-array.ts","src/observe.tsx","src/observables/set.ts","src/observables/map.ts","src/react.tsx"],"sourcesContent":["import \"./observables/object-array\";\nimport \"./observables/set\";\nimport \"./observables/map\";\n\nexport {\n  type ObservableContext,\n  type ObserverActions,\n  observe,\n  unwrap,\n  observableFactories,\n  observerActions,\n  select,\n} from \"./observe\";\n\nexport { objectAndArrayObservableFactory } from \"./observables/object-array\";\n\nexport { useObserver, useObserveSelector } from \"./react\";\n","import { ObservableFactory, observableFactories, unwrap } from \"../observe\";\n\nexport const objectAndArrayObservableFactory: ObservableFactory<\n  Record<string | symbol, unknown>,\n  string | symbol\n> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not really relevant since we always get/set values directly on the context value object.\n      // It's important to pass the original value though, because it needs to be an array for certain internal checks (Array.isArray, for example)\n      ctx.value,\n      {\n        getPrototypeOf() {\n          return Reflect.getPrototypeOf(ctx.value);\n        },\n        getOwnPropertyDescriptor(target, p) {\n          ctx.observeIdentifier(p);\n          return Reflect.getOwnPropertyDescriptor(ctx.value, p);\n        },\n        ownKeys() {\n          return Reflect.ownKeys(ctx.value);\n        },\n        has(_, prop) {\n          ctx.observeIdentifier(prop);\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop) {\n          if (prop === \"toJSON\") return () => ctx.value;\n          const value = Reflect.get(ctx.value, prop, ctx.value);\n          return ctx.observeIdentifier(prop, value);\n        },\n        set(_, prop, value) {\n          const rawValue = unwrap(value);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            if (arrayLength !== ctx.value.length) ctx.modifyIdentifier(\"length\");\n            if (prop !== \"length\") ctx.modifyIdentifier(prop);\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n          ctx.modifyIdentifier(prop);\n          return result;\n        },\n        deleteProperty(_, prop): boolean {\n          const res = Reflect.deleteProperty(ctx.value, prop);\n          if (res) ctx.modifyIdentifier(prop);\n          return res;\n        },\n      }\n    );\n  },\n  handleChange(value, identifier, newValue) {\n    value[identifier] = newValue;\n  },\n  createClone(value: any) {\n    if (Array.isArray(value)) return [...value];\n    const clone = { ...value };\n    Object.setPrototypeOf(clone, Object.getPrototypeOf(value));\n    return clone;\n  },\n};\n\nobservableFactories.set(Object, objectAndArrayObservableFactory);\nobservableFactories.set(Array, objectAndArrayObservableFactory);\n","/**\n *\n *\n *\n */\n\n/**\n * Represents a node in an observable tree. Nodes are shared by all Observers of the same object.\n */\ninterface DataNode {\n  identifier: Identifier;\n  value: object;\n  factory: ObservableFactory<object>;\n  parent: DataNode | undefined;\n  children: Map<Identifier, DataNode>;\n\n  /**\n   * Used to iterate over observers to trigger callbacks.\n   * Keys are child identifiers being observed.\n   * Each value is a Map; keys are the observers and the value is a Set of Selectors.\n   * An empty set indicates that the child is being observed without a selector function and the\n   * observer's callback should be called for any change.\n   * A populated Set indicates that the child is being observed with selectors and the observer's\n   * callback should only be called if at least one of the selectors returns a value different from\n   * its previous invocation.\n   */\n  observersForChild: Map<Identifier, Map<Observer<object>, Set<Selector>>>;\n\n  // Used to determine whether an ObservableContext is still valid\n  allContexts: WeakSet<ObservableContext<object>>;\n}\n\ninterface Observer<T extends object> {\n  isObserving: boolean;\n  observeIntermediates: boolean;\n  callback: Callback | undefined;\n  disposers: Set<() => void>;\n\n  // Used to look up existing ObservableContext for a given DataNode (necessary for maintaining ref equality of observables)\n  contextForNode: WeakMap<DataNode, ObservableContext<object>>;\n\n  actions: ObserverActions;\n}\n\nconst rootIdentifier = Symbol(\"root\");\n\ntype Identifier = unknown | typeof rootIdentifier;\n\n/**\n * Allows looking up an Observable's ObservableContext, so that it can be unwrapped\n */\nconst contextForObservable = new WeakMap<Observable, ObservableContext<object>>();\n\nexport interface ObservableContext<TValue extends object> {\n  dataNode: DataNode;\n  observer: Observer<TValue>;\n  observable: Observable;\n\n  readonly value: TValue;\n\n  /**\n   * Observe a child identifier. Call this to indicate that a user has accessed a property of the observed value. It\n   * will only be observed if the observer is currently enabled.\n   *\n   * `childValue` is mapped to its observable version and returned. It is only necessary to pass it if its type is\n   * unknown and could be an observable value; if you know it's a primitive or otherwise un-observable value, you may\n   * omit it or pass `undefined`.\n   *\n   * `observeIntermediate` is primarily for internal usage. You may pass `true` if you always want to observe the\n   * identifier, regardless of whether it is an intermediate value. Primitives will always be observed, regardless of this value.\n   */\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue?: T,\n    observeIntermediate?: boolean\n  ): T;\n\n  modifyIdentifier(childIdentifier: Identifier): void;\n}\n\ntype Observable = object;\n\ntype Callback = (value: object, identifier: Identifier) => void;\n\n/**\n * The map of object prototypes to their observable factories. Implement an `ObservableFactory` and\n * add it to this map to add support for custom classes.\n */\nexport const observableFactories = new Map<\n  new (...args: any[]) => any,\n  ObservableFactory<any, any>\n>();\n\n/**\n * This interface is used to create observable objects. To create an observable for a class,\n * implement this interface and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue extends object, TIdentifier = unknown> {\n  /**\n   * Returns an object that stands in place of the original value, and can be observed.\n   */\n  makeObservable: (context: ObservableContext<TValue>) => Observable;\n\n  /**\n   * Applies a change to `value` for the given `identifier`.\n   * An example of a change for a plain object would be `value[identifier] = newValue`.\n   */\n  handleChange(value: TValue, identifier: TIdentifier, newValue: unknown): void;\n\n  /**\n   * Returns a clone of `value`.\n   */\n  createClone(value: TValue): object;\n}\n\nconst rootDataNodes = new WeakMap<object, DataNode>();\n\nfunction getDataNode(\n  identifier: Identifier,\n  value: object,\n  parent?: DataNode\n): DataNode | undefined {\n  let dataNode = parent ? parent.children.get(identifier) : rootDataNodes.get(value);\n  if (dataNode) {\n    dataNode.value = value;\n    return dataNode;\n  }\n\n  const factory = observableFactories.get(value.constructor as any);\n  if (!factory) return undefined;\n\n  dataNode = {\n    identifier,\n    value,\n    children: new Map(),\n    parent,\n    factory,\n    observersForChild: new Map(),\n    allContexts: new WeakSet(),\n  };\n  if (parent) parent.children.set(identifier, dataNode);\n  else rootDataNodes.set(value, dataNode);\n  return dataNode;\n}\n\nfunction getObservableContext(\n  observer: Observer<object>,\n  dataNode: DataNode\n): ObservableContext<object> {\n  let ctx = observer.contextForNode.get(dataNode);\n\n  // Check that the context was not previously invalidated\n  if (ctx && !dataNode.allContexts.has(ctx)) {\n    ctx = undefined;\n    observer.contextForNode.delete(dataNode);\n  }\n  if (ctx) return ctx;\n\n  ctx = {\n    dataNode: dataNode,\n    observer: observer,\n    observable: null!,\n    get value() {\n      return this.dataNode.value;\n    },\n    observeIdentifier(identifier, childValue, observeIntermediate = false) {\n      // If the value is a function, bind it to its parent\n      if (typeof childValue === \"function\") {\n        return childValue.bind(this.observable);\n      }\n\n      function addObserver() {\n        if (!observer.isObserving) return;\n\n        let observers = dataNode.observersForChild.get(identifier);\n        if (!observers) dataNode.observersForChild.set(identifier, (observers = new Map()));\n\n        let selectors = observers.get(observer);\n        // A non-selector observation is represented by an empty set\n        const hasNonSelectorObservation = selectors && selectors.size === 0;\n        if (!selectors) observers.set(observer, (selectors = new Set()));\n\n        /**\n         * Since non-selector observations override selector observations (i.e. they would always\n         * cause the callback to be invoked), we don't need to track any additional selectors.\n         * If attempting to add a selector observation, there must not be any existing non-selector\n         * observations.\n         */\n        if (activeSelector) {\n          if (!hasNonSelectorObservation) selectors.add(activeSelector);\n        } else {\n          selectors.clear();\n        }\n\n        observer.disposers.add(() => observers!.delete(observer));\n      }\n\n      if (childValue) {\n        // If the property is something we know how to observe, return the observable value\n        const childNode = getDataNode(identifier, childValue, dataNode);\n        if (childNode) {\n          if (activeSelector || observer.observeIntermediates || observeIntermediate) addObserver();\n          return getObservableContext(observer, childNode).observable;\n        }\n      }\n\n      // If it's a non-observable (i.e. a primitive or unknown object type), just observe and return\n      addObserver();\n      return childValue;\n    },\n    modifyIdentifier(childIdentifier) {\n      if (dataNode.parent) {\n        // Get the factory for the new value\n        dataNode.factory = observableFactories.get(dataNode.value.constructor as any)!;\n        // Clone the value\n        dataNode.value = dataNode.factory.createClone(dataNode.value);\n      }\n\n      // Invalidate Observables for all ObservableContexts of the child Identifier\n      if (dataNode.children.get(childIdentifier))\n        dataNode.children.get(childIdentifier)!.allContexts = new Set();\n\n      // Trigger all Observer callbacks for the child Identifier\n      dataNode.observersForChild.get(childIdentifier)?.forEach((selectors, observer) => {\n        let isAnyDifferent: boolean | undefined = undefined;\n        if (selectors.size) {\n          isAnyDifferent = false;\n          selectors.forEach((selector) => {\n            activeSelector = selector;\n            const newValue = selector.selectorFn();\n            isAnyDifferent =\n              isAnyDifferent || !(selector.isEqual || Object.is)(newValue, selector.lastValue);\n            selector.lastValue = newValue;\n            activeSelector = undefined;\n          });\n        }\n        // @ts-ignore\n        if (isAnyDifferent === true || isAnyDifferent === undefined)\n          observer.callback?.(dataNode.value, childIdentifier);\n      });\n\n      // Let the parent Observable update itself with the cloned child\n      dataNode.parent?.factory.handleChange(\n        dataNode.parent!.value,\n        dataNode.identifier,\n        dataNode.value\n      );\n\n      // Call modifyIdentifier on the parent/root ObservableContext\n      if (childIdentifier !== rootIdentifier)\n        getObservableContext(observer, dataNode.parent || dataNode)?.modifyIdentifier(\n          dataNode.identifier\n        );\n    },\n  };\n  ctx.observable = dataNode.factory.makeObservable(ctx);\n  observer.contextForNode.set(dataNode, ctx);\n  contextForObservable.set(ctx.observable, ctx);\n  dataNode.allContexts.add(ctx);\n  return ctx;\n}\n\nexport interface ObserverActions {\n  /**\n   * Begins listening to property access. This is called automatically when the observer is created,\n   * but may be called again to re-enable the observer after it has been disabled.\n   */\n  start(observeIntermediates?: boolean): void;\n\n  /**\n   * Stops listening to property access.\n   */\n  stop(): void;\n\n  /**\n   * Disables the callback from being invoked on property writes.\n   */\n  disable(): void;\n\n  /**\n   * Enables the callback to be invoked on property writes.\n   */\n  enable(): void;\n\n  /**\n   * Removes all existing observations.\n   */\n  reset(): void;\n}\n\ntype ObserveResponse<TData> = [TData, ObserverActions];\n\nexport function observe<TData extends object>(value: TData, cb: Callback): ObserveResponse<TData>;\n\nexport function observe<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (data: TData) => TSelectorResult,\n  action: (selectorResult: TSelectorResult, value: TData, identifier: Identifier) => void,\n  compare?: (a: TSelectorResult, b: TSelectorResult) => boolean\n): ObserveResponse<TData>;\n\nexport function observe(...args: any) {\n  if (args.length === 2) return createObserver(args[0], args[1]);\n  else return createObserverSelector(args[0], args[1], args[2]);\n}\n\nexport function createObserver<TData extends object>(\n  data: TData,\n  cb: Callback\n): ObserveResponse<TData> {\n  // Get an existing context, if possible. This happens when an observable from another tree is\n  // passed to observe().\n  const ctx = contextForObservable.get(data);\n  const rootNode = ctx?.dataNode || getDataNode(rootIdentifier, data);\n  if (!rootNode) throw new Error(`Cannot observe value ${data}`);\n\n  const observer: Observer<TData> = {\n    isObserving: true,\n    observeIntermediates: false,\n    callback: cb,\n    disposers: new Set(),\n    contextForNode: new WeakMap(),\n    actions: {\n      start(observeIntermediates = false) {\n        observer.isObserving = true;\n        observer.observeIntermediates = observeIntermediates;\n      },\n      stop() {\n        observer.isObserving = false;\n        observer.observeIntermediates = false;\n      },\n      disable() {\n        observer.callback = undefined;\n      },\n      enable() {\n        observer.callback = cb;\n      },\n      reset() {\n        observer.isObserving = false;\n        observer.observeIntermediates = false;\n        observer.disposers.forEach((disposer) => disposer());\n        observer.disposers.clear();\n      },\n    },\n  };\n\n  const store = getObservableContext(observer, rootNode).observable as TData;\n  return [store, observer.actions];\n}\n\n/**\n * Creates an observer and immediately observes the result of the selector function. The selector function is called\n * whenever the value of the observable changes, and the action callback is called whenever the result of the selector\n * function changes.\n *\n * The if the selector function returns a plain array (observables that represent arrays will work normally), it will be\n * shallow compared with the previous value to determine if the observer callback should be called.\n */\nexport function createObserverSelector<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (data: TData) => TSelectorResult,\n  action: (selectorResult: TSelectorResult, value: object, identifier: Identifier) => void,\n  compare: EqualityComparer<TSelectorResult> = Object.is\n): ObserveResponse<TData> {\n  const [state, actions] = observe(data, (value, childIdentifier) =>\n    action(selector(state), value, childIdentifier)\n  );\n\n  select(() => selector(state), compare);\n  actions.stop();\n\n  return [state, actions];\n}\n\ntype EqualityComparer<T> = (a: T, b: T) => boolean;\n\ninterface Selector {\n  lastValue?: any;\n  selectorFn: () => any;\n  isEqual?: EqualityComparer<any>;\n}\n\nlet activeSelector: Selector | undefined;\n\nexport function select<TSelectorResult>(\n  selectorFn: () => TSelectorResult,\n  isEqual?: EqualityComparer<TSelectorResult>\n) {\n  if (activeSelector) throw new Error(\"Cannot nest select() calls\");\n  activeSelector = { selectorFn, isEqual };\n  let lastValue = (activeSelector.lastValue = selectorFn());\n  activeSelector = undefined;\n  return lastValue;\n}\n\n/**\n * \"Unwraps\" a value to give you the original object instead of the observable proxy or subclass. If `observable` is\n * not actually an observable, it will simply be returned as-is.\n */\nexport function unwrap<T>(observable: T, observe = true): T {\n  const ctx = contextForObservable.get(observable as Observable);\n  if (!ctx) return observable;\n  if (observe) {\n    getObservableContext(ctx.observer, ctx.dataNode.parent || ctx.dataNode)?.observeIdentifier(\n      ctx.dataNode.identifier,\n      ctx.value,\n      true\n    );\n  }\n  return ctx.dataNode.value as T;\n}\n\n/**\n * Gets the ObserverActions for an observable. If `observable` is not actually an observable, it will return `undefined`.\n */\nexport function observerActions(observable: any): ObserverActions | undefined {\n  return contextForObservable.get(observable as Observable)?.observer.actions;\n}\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: ObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(callbackFn: (value: T, _key: T, set: Set<T>) => void, thisArg?: any): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): IterableIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n}\n\nobservableFactories.set(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.add(newValue);\n  },\n  createClone(value) {\n    return new Set(value);\n  },\n} as ObservableFactory<Set<unknown>, any>);\n","import { ObservableContext, observableFactories, ObservableFactory } from \"../observe\";\n\nconst _size = Symbol(\"size\");\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: ObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    this.ctx.observeIdentifier(key);\n    return this.map.get(key);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    this.map.set(key, value);\n    if (size !== this.map.size) {\n      this.ctx.modifyIdentifier(key);\n      this.ctx.modifyIdentifier(_size);\n    }\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.ctx.value.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const [key, value] of this.map) {\n      const observable = this.ctx.observeIdentifier(key, value);\n      yield [key, observable];\n    }\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): IterableIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [key, value] of this[Symbol.iterator]()) {\n      yield value;\n    }\n  }\n}\n\nobservableFactories.set(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.set(identifier, newValue);\n  },\n  createClone(value) {\n    return new Map(value);\n  },\n} as ObservableFactory<Map<unknown, unknown>, any>);\n","import React, { useState, useRef, useLayoutEffect, useEffect, useInsertionEffect } from \"react\";\nimport { observe, ObserverActions } from \"./\";\n\nexport function useObserver<TData extends object>(data: TData): TData {\n  const [, forceRerender] = useState({});\n  const [store, actions] = useRef(observe(data, () => forceRerender({}))).current;\n\n  // Begin observing on render\n  actions.reset();\n  actions.start();\n\n  // Stop observing as soon as component finishes rendering\n  useEffect(() => {\n    actions.stop();\n  });\n\n  // Disable callback when component unmounts\n  useEffect(() => {\n    return actions.reset;\n  }, []);\n\n  return store;\n}\n\nexport function useObserveSelector<TData extends object, TSelectorResult>(\n  data: TData,\n  selector: (state: TData) => TSelectorResult,\n  action?: (result: TSelectorResult) => void\n): [TSelectorResult, TData] {\n  const [, forceRerender] = useState({});\n\n  const selectorResultRef = useRef<TSelectorResult>();\n  const [state, actions] = useRef(\n    observe(\n      data,\n      (state) => {\n        return (selectorResultRef.current = selector(state));\n      },\n      (v) => {\n        action?.(v);\n        forceRerender({});\n      }\n    )\n  ).current;\n\n  useEffect(() => {\n    return () => actions.stop();\n  }, []);\n\n  return [selectorResultRef.current as TSelectorResult, state];\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}