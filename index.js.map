{"version":3,"file":"index.js","sources":["src/factories/observableFactories.ts","src/core/ObservableContext.ts","src/methods/deep.ts","src/methods/unwrap.ts","src/util/PathMap.ts","src/methods/derive.ts","src/core/triggerObservations.ts","src/methods/atomic.ts","src/factories/object.ts","src/factories/registerClass.ts","src/factories/map.ts","src/factories/set.ts","src/factories/index.ts","src/methods/disable-enable.ts","src/methods/focus.ts","src/methods/peek.ts","src/core/IsObservable.ts","src/methods/ref.ts","src/methods/silent.ts","src/util/getMapEntry.ts","src/core/RootNode.ts","src/core/Observer.ts","src/methods/observe.ts","src/methods/reset.ts","src/util/shallowCompare.ts"],"sourcesContent":["import type { FactoryObservableContext } from 'keck/core/ObservableContext';\nimport type { AnyConstructor } from 'keck/util/types';\n\n/**\n * The map of object prototypes to their observable factories.\n */\nexport const observableFactories = new Map<AnyConstructor, ObservableFactory<any>>();\n\n/**\n * This interface is used to create observable objects. To create an observable for a class,\n * implement this interface and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue extends object> {\n  /**\n   * Must return an observable wrapper around the given value.\n   */\n  makeObservable: (observableNode: FactoryObservableContext<TValue>) => TValue;\n}\n\nexport function getObservableFactory(\n  classConstructor: AnyConstructor,\n): ObservableFactory<any> | undefined {\n  return observableFactories.get(classConstructor);\n}\n","import { getObservableFactory } from 'keck/factories/observableFactories';\n\nimport type { Observer } from './Observer';\nimport type { Observable, Path, RootNode, Value } from './RootNode';\n\n/**\n * The public interface to an ObservableContext that is made available to Observable factories.\n */\nexport interface FactoryObservableContext<TValue extends object> {\n  value: TValue;\n\n  observeIdentifier<TValue = unknown>(identifier: any, childValue: TValue): TValue;\n  observeIdentifier(identifier: any): void;\n\n  modifyIdentifier(identifier: any): void;\n}\n\nconst contextForObservable = new WeakMap<Observable, ObservableContext<any>>();\n\n/**\n * An ObservableContext is used to manage an Observable (a proxy wrapper) value. Because Observables\n * have to be transparently identical to the value they represent, additional data about them has\n * to be stored in a separate object. ObservableContexts are transient objects that are created\n * internally when a property is accessed, and only exist until a descendant property is modified,\n * which invalidates it and its associated Observable. This invalidation is what allows references\n * to compare as unequal when the underlying value changes.\n *\n * ObservableContext objects are not accessible externally. They only exist while their associated\n * Observable proxy is in scope somewhere (because their factory maintains a reference to it in the\n * proxy or subclass it produces). When the original value is garbage collected, so is the\n * ObservableContext.\n */\nexport class ObservableContext<TValue extends object> {\n  public observable: Observable;\n\n  static getForObservable<TValue extends object>(\n    observable: Observable,\n    throwIfMissing?: true,\n  ): ObservableContext<TValue>;\n  static getForObservable<TValue extends object>(\n    observable: Observable,\n    throwIfMissing: false,\n  ): ObservableContext<TValue> | undefined;\n\n  static getForObservable<TValue extends object>(\n    observable: Observable,\n    throwIfMissing = true,\n  ): ObservableContext<TValue> | undefined {\n    const ctx = contextForObservable.get(observable);\n    if (!ctx && throwIfMissing) {\n      throw new Error('Value is not observable');\n    }\n    return ctx;\n  }\n\n  constructor(\n    public rootNode: RootNode,\n    public observer: Observer,\n    public value: TValue,\n    public path: Path,\n  ) {\n    this.observable = getObservableFactory(value.constructor as any)?.makeObservable(this);\n    if (!this.observable) throw new Error(`Keck: value ${value} is not observable`);\n    contextForObservable.set(this.observable, this);\n  }\n\n  observeIdentifier(identifier: any, childValue?: unknown): unknown {\n    return this.rootNode.observePath(\n      this.observer,\n      [...this.path, identifier],\n      childValue as Value,\n    );\n  }\n\n  /**\n   * Call this method when the value of an identifier has changed. This will notify any observers\n   * to trigger their callbacks, if necessary.\n   *\n   * @param identifier The identifier that has changed.\n   */\n  modifyIdentifier(identifier: any): void {\n    this.rootNode.modifyPath([...this.path, identifier]);\n  }\n}\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport type { Observable, Value } from 'keck/core/RootNode';\n\nexport function deep<T extends object>(observable: T): T {\n  const ctx = ObservableContext.getForObservable(observable as Observable);\n  return ctx.observer.rootNode.observePath(ctx.observer, ctx.path, ctx.value as Value, true) as T;\n}\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport type { Observable } from 'keck/core/RootNode';\nimport { deep } from 'keck/methods/deep';\n\n/**\n * Returns the original object of an observable wrapper. If `observable` is\n * not actually an observable, the value will be returned as-is.\n */\nexport function unwrap<T>(observable: T, deepObserve = false): T {\n  const ctx = ObservableContext.getForObservable(observable as Observable, false);\n  if (ctx) {\n    if (deepObserve) deep(observable as object);\n    return ctx.value as T;\n  }\n  return observable;\n}\n","export type Path = any[];\n\nconst pathValue = Symbol('pathValue');\n\nexport class PathMap<V> {\n  private readonly root: WeakMap<any, any> | Map<any, any>;\n\n  constructor(options?: { weak: boolean }) {\n    this.root = options?.weak ? new WeakMap() : new Map();\n  }\n\n  set(path: Path, value: V): void {\n    let currentLevel = this.root;\n\n    for (let i = 0; i < path.length; i++) {\n      let child = currentLevel.get(path[i]);\n      if (!child) {\n        child = new Map();\n        currentLevel.set(path[i], child);\n      }\n      currentLevel = child;\n    }\n\n    currentLevel.set(pathValue, value);\n  }\n\n  /**\n   * Returns the value at the given path, and all children of the path.\n   */\n  get(path: Path): V | undefined {\n    let currentLevel = this.root;\n\n    for (let i = 0; i < path.length; i++) {\n      currentLevel = currentLevel.get(path[i]);\n      if (!currentLevel) {\n        return undefined;\n      }\n    }\n\n    return currentLevel.get(pathValue);\n  }\n\n  /**\n   * Collects all values located at the given path, all of its parents, and all of its descendants into a flat array.\n   */\n  collect(path: Path, type: 'ancestors' | 'children' | 'all' = 'all'): V[] {\n    if (!(this.root as Map<any, any>).entries) {\n      throw new Error('Cannot call `collect` on a weak PathMap!');\n    }\n\n    const result: V[] = [];\n\n    let currentLevel = this.root as Map<any, any>;\n\n    const ancestors = type === 'ancestors' || type === 'all';\n\n    let i = 0;\n    for (; i < path.length; i++) {\n      if (ancestors && currentLevel.has(pathValue)) {\n        result.push(currentLevel.get(pathValue));\n      }\n      currentLevel = currentLevel.get(path[i]);\n      if (!currentLevel) return result;\n    }\n\n    if (currentLevel.has(pathValue)) result.push(currentLevel.get(pathValue));\n\n    if (type === 'children' || type === 'all') {\n      this.collectChildren(currentLevel as Map<any, any>, result);\n    }\n\n    return result;\n  }\n\n  private collectChildren(entry: Map<any, any>, result: V[]) {\n    for (const child of entry.entries()) {\n      if (child[0] !== pathValue) {\n        if (child[1].has(pathValue)) {\n          result.push(child[1].get(pathValue));\n        }\n        this.collectChildren(child[1], result);\n      }\n    }\n  }\n}\n","import { unwrap } from 'keck/methods/unwrap';\nimport { PathMap } from 'keck/util/PathMap';\n\nexport type DeriveFn<T> = () => T;\nexport type DeriveEqualFn<T> = (prevResult: T, nextResult: T) => boolean;\nexport type DeriveContext<T> = { fn: DeriveFn<T>; isEqual?: DeriveEqualFn<T>; prevResult: any };\n\nexport let activeDeriveCtx: DeriveContext<any> | undefined;\n\nconst deriveCtxs = new PathMap<DeriveContext<any>>({ weak: true });\n\nexport function derive<T>(fn: DeriveFn<T>, isEqual?: DeriveEqualFn<T>) {\n  let thisSetCallback = false;\n  if (!activeDeriveCtx) {\n    activeDeriveCtx = deriveCtxs.get([fn, isEqual]);\n    if (!activeDeriveCtx) {\n      activeDeriveCtx = { fn, isEqual, prevResult: undefined };\n      deriveCtxs.set([fn, isEqual], activeDeriveCtx);\n    }\n    thisSetCallback = true;\n  }\n  try {\n    return (activeDeriveCtx.prevResult = unwrap(fn()));\n  } finally {\n    if (thisSetCallback) {\n      activeDeriveCtx = undefined;\n    }\n  }\n}\n\n/**\n * Invokes the derive function of the given context, while setting it as the activeDeriveCtx.\n * This allows any observations made during the derive function to continue being derived observations.\n */\nexport function invokeDeriveCtx(ctx: DeriveContext<any>) {\n  let thisSetCallback = false;\n  if (!activeDeriveCtx) {\n    activeDeriveCtx = ctx;\n    thisSetCallback = true;\n  }\n  try {\n    return (activeDeriveCtx.prevResult = activeDeriveCtx.fn());\n  } finally {\n    if (thisSetCallback) {\n      activeDeriveCtx = undefined;\n    }\n  }\n}\n","import type { Observation, Observer } from 'keck/core/Observer';\nimport { type DeriveContext, invokeDeriveCtx } from 'keck/methods/derive';\n\nexport function triggerObservations(observations: Set<Observation>) {\n  // The Set of Observers to trigger (prevents triggering the same observer multiple times)\n  const triggerObservers = new Set<Observer>();\n\n  // Map of validated DeriveContexts and whether their return values changed\n  // (prevents redundant invocations of derive fn or isEqual)\n  const verifiedDeriveCtxs = new Map<DeriveContext<any>, boolean>();\n\n  for (const observation of observations) {\n    // By default, we don't skip any Observer callback (for non-focused Observers)\n    let skipObserver = false;\n\n    // If the observation has derive contexts, validate each one\n    if (observation.deriveCtxs) {\n      // In this case, we skip the observer by default unless one of the derived return values changed\n      skipObserver = true;\n\n      for (const deriveCtx of observation.deriveCtxs) {\n        // Already checked; skip and use same result\n        if (verifiedDeriveCtxs.has(deriveCtx)) {\n          const changedResult = verifiedDeriveCtxs.get(deriveCtx);\n          if (changedResult) skipObserver = false;\n          continue;\n        }\n\n        // Get next result and compare with previous result\n        const prevResult = deriveCtx.prevResult;\n        const nextResult = invokeDeriveCtx(deriveCtx);\n        const changedResult = deriveCtx.isEqual\n          ? !deriveCtx.isEqual(prevResult, nextResult)\n          : prevResult !== nextResult;\n\n        verifiedDeriveCtxs.set(deriveCtx, changedResult);\n\n        // If the result changed, this observer will be invoked\n        if (changedResult) skipObserver = false;\n      }\n    }\n\n    if (!skipObserver) triggerObservers.add(observation.observer);\n  }\n\n  for (const observer of triggerObservers) {\n    observer.callback?.();\n  }\n}\n","import type { Observation } from 'keck/core/Observer';\nimport { triggerObservations } from 'keck/core/triggerObservations';\n\nexport let atomicObservations: Set<Observation> | undefined;\n\nexport function atomic<T>(\n  fn: (...args: unknown[]) => unknown,\n  args?: unknown[],\n  thisArg?: unknown,\n): T;\n\nexport function atomic<T, TArgs extends unknown[]>(\n  fn: (...args: TArgs) => T,\n  args: TArgs,\n  thisArg?: unknown,\n): T;\n\nexport function atomic<TReturn, TArgs extends any[]>(\n  fn: (...args: TArgs) => TReturn,\n  args?: TArgs,\n  thisArg?: unknown,\n): TReturn {\n  let thisSetCallback = false;\n  if (!atomicObservations) {\n    atomicObservations = new Set();\n    thisSetCallback = true;\n  }\n  try {\n    return fn.apply(thisArg, args as TArgs);\n  } finally {\n    if (thisSetCallback) {\n      triggerObservations(atomicObservations);\n      atomicObservations = undefined;\n    }\n  }\n}\n","import type { ObservableFactory } from 'keck/factories/observableFactories';\nimport { atomic } from 'keck/methods/atomic';\nimport { unwrap } from 'keck/methods/unwrap';\n\nexport const objectFactory: ObservableFactory<Record<string | symbol, unknown>> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not really relevant since we always get/set values directly on the context value object.\n      // It's important to pass the original value though, because it needs to be an array for certain internal checks (Array.isArray, for example)\n      ctx.value,\n      {\n        has(_, prop) {\n          ctx.observeIdentifier(prop);\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop, observable) {\n          // if (prop === \"toJSON\") return () => ctx.value;\n          const propValue = Reflect.get(ctx.value, prop, observable);\n          if (typeof propValue === 'function') {\n            return (...args: unknown[]) => {\n              // Todo cache function?\n              return atomic(propValue as () => unknown, args, observable);\n            };\n          }\n          return ctx.observeIdentifier(prop, propValue);\n        },\n        set(_, prop, newValue, observer) {\n          const rawValue = unwrap(newValue);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            atomic(() => {\n              if (arrayLength !== ctx.value.length) ctx.modifyIdentifier('length');\n              if (prop !== 'length') ctx.modifyIdentifier(prop);\n            });\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, observer);\n          ctx.modifyIdentifier(prop);\n          return result;\n        },\n        ownKeys(_) {\n          const keys = Reflect.ownKeys(ctx.value);\n          for (const key of keys) {\n            ctx.observeIdentifier(key);\n          }\n          return keys;\n        },\n        deleteProperty(_, prop): boolean {\n          const res = Reflect.deleteProperty(ctx.value, prop);\n          if (res) ctx.modifyIdentifier(prop);\n          return res;\n        },\n      },\n    );\n  },\n};\n","import { objectFactory } from 'keck/factories/object';\n\nimport type { AnyConstructor } from 'keck/util/types';\nimport { type ObservableFactory, observableFactories } from './observableFactories';\n\n/**\n * Registers a class that can be observed. You can provide a custom factory that produces observable\n * instances of the class. If no factory is provided, the default object factory will be used.\n * @param classConstructor The class to register.\n * @param factory The factory to use to create observable instances of the class.\n */\nexport function registerClass(classConstructor: AnyConstructor, factory?: ObservableFactory<any>) {\n  observableFactories.set(classConstructor, factory || objectFactory);\n}\n","import type { FactoryObservableContext } from 'keck/core/ObservableContext';\nimport type { ObservableFactory } from 'keck/factories/observableFactories';\nimport { registerClass } from 'keck/factories/registerClass';\nimport { atomic } from 'keck/methods/atomic';\n\nconst _size = Symbol('size');\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: FactoryObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) {\n      atomic(() => {\n        this.ctx.modifyIdentifier(key);\n        this.ctx.modifyIdentifier(_size);\n      });\n    }\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    const value = this.map.get(key);\n    return this.ctx.observeIdentifier(key, value);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    const oldValue = this.map.get(key);\n    this.map.set(key, value);\n    atomic(() => {\n      if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n      if (oldValue !== value) this.ctx.modifyIdentifier(key);\n    });\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.ctx.value.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): MapIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const entry of this.map) {\n      const observable = this.ctx.observeIdentifier(entry[0], entry[1]);\n      yield [entry[0], observable];\n    }\n  }\n\n  entries(): MapIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): MapIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): MapIterator<V> {\n    for (const value of this[Symbol.iterator]()) {\n      yield value[1];\n    }\n  }\n}\n\nregisterClass(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n} satisfies ObservableFactory<Map<unknown, unknown>>);\n","import type { FactoryObservableContext } from 'keck/core/ObservableContext';\nimport type { ObservableFactory } from 'keck/factories/observableFactories';\nimport { registerClass } from 'keck/factories/registerClass';\n\nconst _size = Symbol('size');\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: FactoryObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(callbackFn: (value: T, _key: T, set: Set<T>) => void, thisArg?: any): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): SetIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): SetIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): SetIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): SetIterator<T> {\n    return this[Symbol.iterator]();\n  }\n}\n\nregisterClass(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n} satisfies ObservableFactory<Set<unknown>>);\n","import './map';\nimport { objectFactory } from './object';\nimport { registerClass } from './registerClass';\nimport './set';\n\nregisterClass(Object, objectFactory);\nregisterClass(Array, objectFactory);\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport type { Observable } from 'keck/core/RootNode';\n\n/**\n * Disables an observer, preventing it from triggering its callback when its\n * observed properties are modified.\n * @param observable The observable to disable.\n */\nexport function disable(observable: object) {\n  ObservableContext.getForObservable(observable as Observable).observer.disable();\n}\n\n/**\n * Enables an observer, allowing it to trigger its callback when its observed\n * properties are modified.\n * @param observable The observable to enable.\n */\nexport function enable(observable: object) {\n  ObservableContext.getForObservable(observable as Observable).observer.enable();\n}\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport type { Observable } from 'keck/core/RootNode';\n\nexport function focus(observable: any, enableFocus = true) {\n  ObservableContext.getForObservable(observable as Observable).observer.focus(enableFocus);\n}\n","let peeking = false;\n\nexport function isPeeking() {\n  return peeking;\n}\n\nexport function peek<T>(fn: () => T): T {\n  peeking = true;\n  try {\n    return fn();\n  } finally {\n    peeking = false;\n  }\n}\n","import { getObservableFactory } from \"keck/factories/observableFactories\";\n\nexport function isObservable(value: any, throwEx = false): value is object {\n  if (value && typeof value === 'object' && getObservableFactory(value.constructor)) {\n    return true;\n  }\n  if (throwEx) {\n    let valueLabel = String(value);\n    if (value && (typeof value === 'object' || typeof value === 'function'))\n      valueLabel = `of type ${value.constructor.name}`;\n    else if (typeof value === 'string') valueLabel = `\"${value}\"`;\n    throw new Error(`Value ${valueLabel} is not observable`);\n  }\n  return false;\n}","import { isObservable } from \"keck/core/IsObservable\";\n\nconst refMap = new WeakSet<object>();\n\nexport function ref<T>(value: T): T {\n  if (isObservable(value)) refMap.add(value);\n  return value;\n}\n\nexport function isRef(value: any): boolean {\n  return refMap.has(value);\n}\n","export let silentMode = false;\n\n/**\n * Use `silent` to execute a block of code without triggering any observer callbacks when modifications are made.\n * @param callback The block of code to execute.\n */\nexport function silent(callback: () => void) {\n  silentMode = true;\n  callback();\n  silentMode = false;\n}\n","export function getMapEntry<TKey, TValue, TCreate extends TValue>(\n  map: { get(key: TKey): TValue | undefined; set(key: TKey, value: TValue): void },\n  key: TKey,\n  create: () => TCreate,\n  meta?: { created?: boolean },\n  isEntryValid?: (entry: TValue) => boolean,\n): TValue {\n  let value = map.get(key as any);\n  if (!value || (isEntryValid && !isEntryValid(value))) {\n    value = create();\n    map.set(key as any, value);\n    if (meta) meta.created = true;\n  }\n  return value;\n}\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport { getObservableFactory } from 'keck/factories/observableFactories';\nimport { atomicObservations } from 'keck/methods/atomic';\nimport { activeDeriveCtx } from 'keck/methods/derive';\nimport { isPeeking } from 'keck/methods/peek';\nimport { isRef } from 'keck/methods/ref';\nimport { silentMode } from 'keck/methods/silent';\nimport { PathMap } from 'keck/util/PathMap';\nimport { getMapEntry } from 'keck/util/getMapEntry';\n\nimport { isObservable } from 'keck/core/IsObservable';\nimport { triggerObservations } from 'keck/core/triggerObservations';\nimport type { AnyConstructor } from 'keck/util/types';\nimport type { Observation, Observer } from './Observer';\n\n/**\n * Branded type for a plain value that can be observed. Used to differentiate in usage from an\n * Observable.\n */\nexport type Value = object & { __value: true };\n\n/**\n * Branded type for an observable object proxy or subclass. Used to differentiate in usage from a\n * Value.\n */\nexport type Observable = object & { __observable: true };\n\n/**\n * An array of values used to identify the \"path\" to a value in an observable object graph.\n */\nexport type Path = any[];\n\ninterface ObservablePathEntry {\n  /**\n   * Used to look up an existing ObservableContext for an Observer at the given path,\n   * and to invalidate all ObservableContexts for an Observer at a given path.\n   *\n   * TODO should there be a separate WeakMap for Observables? It might be more performant to\n   *  only invalidate Observables but leave their ObservableContexts intact and reuse them by\n   *  reassigning an Observable when it is recreated.\n   */\n  observables: WeakMap<Observer, ObservableContext<any>>;\n  observations: Map<Observer, Observation>; // to look up observations by Observer\n}\n\nexport const rootNodeForValue = new WeakMap<Value, WeakRef<RootNode>>();\n\nexport function getRootNodeForValue(value: Value) {\n  isObservable(value, true);\n  return getMapEntry(\n    rootNodeForValue,\n    value,\n    () => new WeakRef(new RootNode()),\n    {},\n    (ref) => !!ref.deref(),\n  ).deref()!;\n}\n\nexport class RootNode {\n  pathEntries = new PathMap<ObservablePathEntry>();\n\n  observePath(observer: Observer, path: Path, childValue: Value, force = false) {\n    let returnValue = childValue;\n\n    if (isPeeking()) return returnValue;\n\n    const isObservable =\n      childValue &&\n      typeof childValue === 'object' &&\n      getObservableFactory(childValue.constructor as AnyConstructor) &&\n      !isRef(childValue);\n\n    // If the given value is observable, return the observable for it\n    if (isObservable) {\n      returnValue = this.getObservable(observer, path, childValue) as any as Value;\n    }\n\n    if (force || activeDeriveCtx || (!isObservable && observer.isFocusing)) {\n      this.createObservation(observer, path);\n    }\n\n    return returnValue;\n  }\n\n  modifyPath(path: Path) {\n    // Invalidate observables for this and all related paths\n    const ancestors = this.pathEntries.collect(path, 'all');\n    for (const pathEntry of ancestors) {\n      pathEntry.observables = new WeakMap();\n    }\n\n    if (silentMode) return;\n\n    const observationsToCall = atomicObservations || new Set();\n\n    const pathEntries = this.pathEntries.collect(path);\n\n    for (const pathEntry of pathEntries) {\n      for (const observation of pathEntry.observations.values()) {\n        if (!observation.observer.enabled) continue;\n\n        // If the Observation is not valid, remove it from the map\n        // (it could have been cleared out by resetting the observer)\n        if (!observation.observer.hasObservation(observation)) {\n          pathEntry.observations.delete(observation.observer);\n          continue;\n        }\n\n        observationsToCall.add(observation);\n      }\n    }\n\n    // If atomicObservers is set, then `atomic()` will handle calling the observers\n    if (observationsToCall !== atomicObservations) {\n      triggerObservations(observationsToCall);\n    }\n  }\n\n  getObservable(observer: Observer, path: Path, childValue: Value) {\n    isObservable(childValue, true);\n\n    return getMapEntry(\n      this.getPathEntry(path).observables,\n      observer,\n      () => new ObservableContext(this, observer, childValue, path),\n    ).observable;\n  }\n\n  private getPathEntry(path: Path) {\n    return getMapEntry(\n      this.pathEntries,\n      path,\n      () => ({ observables: new WeakMap(), observations: new Map() }) satisfies ObservablePathEntry,\n    );\n  }\n\n  createObservation(observer: Observer, path: Path) {\n    const pathEntry = this.getPathEntry(path);\n    const getObservationMeta = { created: false };\n    const observation = getMapEntry(\n      pathEntry.observations,\n      observer,\n      () => ({ observer, path }),\n      getObservationMeta,\n      (entry) => observer.hasObservation(entry),\n    );\n\n    // If there's no activeDeriveCtx, then clear the set (the observation is unconditional)\n    if (!activeDeriveCtx) {\n      observation.deriveCtxs = undefined;\n    }\n    // If there's an activeDeriveCtx, and we just created the observation or there is an existing Set of deriveCtxs, add it to the Set.\n    // Otherwise, there is already an unconditional observation and we shouldn't add this derive fn.\n    else if (getObservationMeta.created || observation.deriveCtxs) {\n      observation.deriveCtxs = observation.deriveCtxs || new Set();\n      observation.deriveCtxs.add(activeDeriveCtx);\n    }\n\n    observer.addObservation(observation);\n  }\n}\n","import type { DeriveContext } from 'keck/methods/derive';\n\nimport { type RootNode, type Value, getRootNodeForValue } from './RootNode';\n\n/**\n * An Observation represents a path that was accessed on an Observable for a specific Observer,\n * and should trigger the Observer's callback when that property is modified.\n * When an Observable's property is modified, each Observation is tested, and if all conditions are\n * met, it will trigger the callback for its associated Observer.\n *\n * These are stored in a PathMap on the RootNode, which is used to look up all Observations for a\n * given path, regardless of the Observer that created them. They are also stored in a WeakMap on the\n * Observer, which is used to invalidate Observations when the Observer's mode is changed.\n */\nexport interface Observation {\n  /**\n   * The Observer associated with this Observation.\n   */\n  observer: Observer;\n\n  /**\n   * The DeriveContexts that were active when a property was accessed, that are tested to check if\n   * the Observer's callback should be triggered.\n   * `undefined` here indicates that the property was accessed without a derive function, so the\n   * observation is unconditional.\n   */\n  deriveCtxs?: Set<DeriveContext<any>>;\n}\n\nexport class Observer {\n  private _enabled = true;\n\n  /**\n   * Indicates whether focus mode is enabled, disabled, or paused for this Observer.\n   * - `undefined`: focus is disabled (all modifications are observed)\n   * - `true`: focus is enabled\n   * - `false`: focus is paused (new observations are not created but existing ones are still valid)\n   */\n  private _isFocusing: boolean | undefined = undefined;\n\n  rootNode: RootNode;\n\n  /**\n   * A WeakSet of Observations for this Observer; used to invalidate Observables when the Observer's\n   * focus mode is disabled.\n   */\n  private _validObservations?: WeakSet<Observation>;\n\n  constructor(\n    value: Value,\n    public callback?: () => void,\n  ) {\n    this.rootNode = getRootNodeForValue(value);\n    this.createRootObservation();\n  }\n\n  get isFocusing() {\n    return this._isFocusing;\n  }\n\n  focus(enableFocus: boolean) {\n    // Reset observations when enabling focus mode\n    if (this._isFocusing === undefined && enableFocus) {\n      this._validObservations = undefined;\n    }\n    this._isFocusing = enableFocus;\n  }\n\n  /**\n   * Resets all observations of properties of the observable.\n   */\n  reset() {\n    if (this._isFocusing === undefined) {\n      throw new Error('reset() can only be called in focus mode');\n    }\n    this._validObservations = undefined;\n  }\n\n  /**\n   * Creates an observation on the root, which will trigger the callback\n   * when any property is modified if this Observer is not in focus mode\n   * @private\n   */\n  private createRootObservation() {\n    this.rootNode.createObservation(this, []);\n  }\n\n  disable() {\n    this._enabled = false;\n  }\n\n  enable() {\n    this._enabled = true;\n  }\n\n  get enabled() {\n    return this._enabled;\n  }\n\n  addObservation(observation: Observation) {\n    if (!this._validObservations) this._validObservations = new WeakSet();\n    this._validObservations.add(observation);\n  }\n\n  hasObservation(observation: Observation) {\n    return !!this._validObservations?.has(observation);\n  }\n}\n","import { Observer } from 'keck/core/Observer';\nimport type { Value } from 'keck/core/RootNode';\n\nimport { type DeriveEqualFn, derive } from './derive';\nimport { focus } from './focus';\nimport { unwrap } from './unwrap';\n\ntype ObserverDeriveFn<TValue, TDerived> = (state: TValue) => TDerived;\n\nexport function observe<TValue extends object, TDerive>(\n  value: TValue,\n  cb?: () => void,\n  deriveFn?: ObserverDeriveFn<TValue, TDerive>,\n  isEqual?: DeriveEqualFn<TDerive>,\n): TValue {\n  value = unwrap(value);\n  const observer = new Observer(value as Value, cb);\n  const state = observer.rootNode.getObservable(observer, [], value as Value) as TValue;\n  if (deriveFn) {\n    focus(state);\n    derive(() => deriveFn!(state), isEqual);\n    focus(state, false);\n  }\n  return state;\n}\n","import { ObservableContext } from 'keck/core/ObservableContext';\nimport type { Observable } from 'keck/core/RootNode';\n\nexport function reset(observable: any) {\n  ObservableContext.getForObservable(observable as Observable).observer.reset();\n}\n","/**\n * Compares two objects for shallow equality. This is provided as a convenience utility for the k.derive()\n * method.\n *\n * @param a The value to compare\n * @param b The value to compare against\n */\nexport function shallowCompare<T>(a: T, b: T): boolean {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a === null || b === null) return false;\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const key of aKeys) {\n    if ((a as any)[key] !== (b as any)[key]) return false;\n  }\n  return true;\n}\n"],"names":["_size"],"mappings":"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"}