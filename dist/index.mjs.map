{"mappings":";;AEsBA,MAAM,uCAAiB,OAAO;AA+BvB,MAAM,4CAAsB,IAAI;AAKhC,MAAM,4CAAa,OAAO;AAwBjC,MAAM,uCAAiB,IAAI;AAQ3B,SAAS,mCACP,UAAsB,EACtB,KAAa,EACb,MAAkB,EACK;IACvB,IAAI,YAAY,SAAS,OAAO,QAAQ,CAAC,GAAG,CAAC,cAAc,qCAAe,GAAG,CAAC,MAAM;IACpF,IAAI,WAAW;QACb,UAAU,KAAK,GAAG;QAClB,OAAO;IACT,CAAC;IAED,MAAM,UAAU,0CAAoB,GAAG,CAAC,MAAM,WAAW;IACzD,IAAI,CAAC,SAAS,OAAO;IAErB,YAAY;oBACV;eACA;QACA,UAAU,IAAI;gBACd;iBACA;QACA,gBAAgB,IAAI;QACpB,oBAAoB,IAAI;IAC1B;IACA,IAAI,QAAQ,OAAO,QAAQ,CAAC,GAAG,CAAC,YAAY;SACvC;QACF,UAA4B,MAAM,GAAG,IAAI;QAC1C,qCAAe,GAAG,CAAC,OAAO;IAC5B,CAAC;IACD,OAAO;AACT;AAEA,SAAS,2CAAqB,QAAkB,EAAE,SAAoB,EAAqB;IACzF,IAAI,MAAM,UAAU,kBAAkB,CAAC,GAAG,CAAC;IAC3C,IAAI,KAAK,OAAO;IAEhB,IAAI;IACJ,MAAM;mBACJ;kBACA;QACA,IAAI,SAAQ;YACV,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK;QAC7B;QACA,IAAI,cAAa;YACf,OAAO,cAAe,CAAA,aAAa,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAA;QAC/E;QACA,wBAAuB;YACrB,aAAa;QACf;QACA,mBAAkB,UAAU,EAAE,UAAU,EAAE,sBAAsB,KAAK,EAAE;YACrE,oDAAoD;YACpD,IAAI,OAAO,eAAe,YACxB,OAAO,WAAW,IAAI,CAAC,IAAI,CAAC,UAAU;YAGxC,SAAS,cAAc;gBACrB,IAAI,CAAC,SAAS,WAAW,EAAE;gBAC3B,IAAI,YAAY,UAAU,cAAc,CAAC,GAAG,CAAC;gBAC7C,IAAI,CAAC,WAAW,UAAU,cAAc,CAAC,GAAG,CAAC,YAAa,YAAY,IAAI;gBAC1E,UAAU,GAAG,CAAC;gBACd,SAAS,SAAS,CAAC,GAAG,CAAC,IAAM,UAAW,MAAM,CAAC;YACjD;YAEA,IAAI,YAAY;gBACd,mFAAmF;gBACnF,MAAM,iBAAiB,mCAAa,YAAY,YAAY,YAAY,+DAA+D;gBACvI,IAAI,gBAAgB;oBAClB,IAAI,qBAAqB;oBACzB,OAAO,2CAAqB,UAAU,gBAAgB,UAAU;gBAClE,CAAC;YACH,CAAC;YAED,8FAA8F;YAC9F;YACA,OAAO;QACT;QACA,kBAAiB,eAAe,EAAE;YAChC,IAAI,UAAU,MAAM,EAAE;gBACpB,oCAAoC;gBACpC,UAAU,OAAO,GAAG,0CAAoB,GAAG,CAAC,UAAU,KAAK,CAAC,WAAW;gBACvE,kBAAkB;gBAClB,UAAU,KAAK,GAAG,UAAU,OAAO,CAAC,WAAW,CAAC,UAAU,KAAK;YACjE,CAAC;YAED,4EAA4E;YAC5E,UAAU,QAAQ,CACf,GAAG,CAAC,kBACH,mBAAmB,OAAO,CAAC,CAAC,MAAQ,IAAI,oBAAoB;YAEhE,0DAA0D;YAC1D,UAAU,cAAc,CAAC,GAAG,CAAC,kBAAkB,QAAQ,CAAC,WAAa;gBACnE,SAAS,QAAQ,GAAG,UAAU,KAAK,EAAE;YACvC;YAEA,gEAAgE;YAChE,UAAU,MAAM,EAAE,QAAQ,YAAY,CACpC,UAAU,MAAM,CAAE,KAAK,EACvB,UAAU,UAAU,EACpB,UAAU,KAAK;YAGjB,6DAA6D;YAC7D,IAAI,UAAU,MAAM,EAClB,UAAU,MAAM,EAAE,mBAAmB,GAAG,CAAC,UAAW,gBAAgB,CAAC,UAAU,UAAU;iBACtF,IAAI,oBAAoB,sCAC3B,UAAU,kBAAkB,CAAC,GAAG,CAAC,UAAW,gBAAgB,CAAC;QACjE;IACF;IACA,UAAU,kBAAkB,CAAC,GAAG,CAAC,UAAU;IAC3C,OAAO;AACT;AAEO,SAAS,yCAAiC,IAAO,EAAE,QAAkB,EAAE;IAC5E,OAAO,yCAAO,MAAM,KAAK;IACzB,MAAM,gBAAgB,mCAAa,sCAAgB;IACnD,IAAI,CAAC,eAAe,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,KAAK,CAAC,EAAE;IAEpE,MAAM,WAAqB;QACzB,aAAa,IAAI;kBACjB;QACA,WAAW,IAAI;IACjB;IAEA,OAAO;QACL,OAAO,2CAAqB,UAAU,eAAe,UAAU;QAC/D,WAAU;YACR,SAAS,WAAW,GAAG,IAAI;QAC7B;QACA,aAAY;YACV,SAAS,WAAW,GAAG,KAAK;QAC9B;QACA,SAAQ;YACN,SAAS,SAAS,CAAC,OAAO,CAAC,CAAC,WAAa;YACzC,SAAS,SAAS,CAAC,KAAK;QAC1B;QACA,WAAU;YACR,SAAS,WAAW,GAAG,KAAK;YAC5B,SAAS,QAAQ,GAAG;QACtB;QACA,UAAS;YACP,SAAS,QAAQ,GAAG;QACtB;IACF;AACF;AAEO,SAAS,yCAAU,UAAa,EAAE,UAAU,IAAI,EAAK;IAC1D,MAAM,MAAO,YAA2B,CAAC,0CAAW;IACpD,IAAI,CAAC,KAAK,OAAO;IACjB,IAAI;QACF,IAAI,IAAI,SAAS,CAAC,MAAM,EACtB,IAAI,SAAS,CAAC,MAAM,CAAC,kBAAkB,CACpC,GAAG,CAAC,IAAI,QAAQ,GACf,kBAAkB,IAAI,SAAS,CAAC,UAAU,EAAE,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI;aAEzE,IAAI,SAAS,CAAC,kBAAkB,CAC7B,GAAG,CAAC,IAAI,QAAQ,GACf,kBAAkB,sCAAgB;KAEzC;IACD,OAAO,IAAI,SAAS,CAAC,KAAK;AAC5B,EAEA;;;;;;;;;;;;;;;;;;;CAmBC;;AD9QD;AAQO,MAAM,4CAGT;IACF,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,MACT,+GAA+G;QAC/G,2DAA2D;QAC3D,KACA;YACE,KAAI,CAAC,EAAE,IAAI,EAAE;gBACX,IAAI,SAAS,CAAA,GAAA,yCAAU,AAAD,GAAG,OAAO,IAAI;gBACpC,OAAO,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE;YAChC;YACA,KAAI,CAAC,EAAE,IAAI,EAAE;gBACX,IAAI,SAAS,CAAA,GAAA,yCAAU,AAAD,GAAG,OAAO,IAAM;gBAEtC,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,IAAI,KAAK;gBACpD,OAAO,IAAI,iBAAiB,CAAC,MAAM;YACrC;YACA,KAAI,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;gBAClB,IAAI,SAAS,CAAA,GAAA,yCAAU,AAAD,GAAG,OAAO,IAAI;gBAEpC,MAAM,WAAW,CAAA,GAAA,wCAAK,EAAE;gBACxB,MAAM,WAAW,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,IAAI,KAAK;gBACvD,IAAI,aAAa,UAAU,OAAO,IAAI;gBAEtC,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,GAAG;oBAC5B,MAAM,cAAc,IAAI,KAAK,CAAC,MAAM;oBAEpC,MAAM,YAAY,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,UAAU,IAAI,KAAK;oBAElE,IAAI,gBAAgB,IAAI,KAAK,CAAC,MAAM,EAAE,IAAI,gBAAgB,CAAC;oBAC3D,IAAI,SAAS,UAAU,IAAI,gBAAgB,CAAC;oBAE5C,OAAO;gBACT,CAAC;gBAED,MAAM,SAAS,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAE,MAAM,UAAU,IAAI,KAAK;gBAC/D,IAAI,gBAAgB,CAAC;gBACrB,OAAO;YACT;YACA,gBAAe,CAAC,EAAE,CAAC,EAAW;gBAC5B,MAAM,SAAS,QAAQ,cAAc,CAAC,IAAI,KAAK,EAAE;gBACjD,IAAI,gBAAgB,CAAC;gBACrB,OAAO;YACT;QACF;IAEJ;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,KAAK,CAAC,WAAW,GAAG;IACtB;IACA,aAAY,KAAU,EAAE;QACtB,IAAI,MAAM,OAAO,CAAC,QAAQ,OAAO;eAAI;SAAM;QAC3C,MAAM,QAAQ;YAAE,GAAG,KAAK;QAAC;QACzB,OAAO,cAAc,CAAC,OAAO,OAAO,cAAc,CAAC;QACnD,OAAO;IACT;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,QAAQ;AAChC,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,OAAO;;ADtE/B;AGAA;AAMA,MAAM,8BAAQ,OAAO;AAErB,MAAM,4CAAyB;IAC7B,YAAoB,IAAgC;QAClD,KAAK;mBADa;IAEpB;IAEA,IAAY,MAAc;QACxB,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK;IACvB;IAEA,IAAI,KAAQ,EAAQ;QAClB,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;QACb,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACtD,OAAO,IAAI;IACb;IAEA,QAAc;QACZ,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,KAAK;QACd,kCAAkC;QAClC,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACxD;IAEA,OAAO,KAAQ,EAAW;QACxB,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;QAC5B,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACnC,OAAO;IACT;IAEA,QACE,UAAoD,EACpD,OAAa,EACP;QACN,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,OAAS;YAChC,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO;YACrD,WAAW,IAAI,CAAC,SAAS,YAAY,YAAY,IAAI;QACvD,GAAG;QACE,IAAI,CAAC,IAAI;IAChB;IAEA,IAAI,KAAQ,EAAW;QACrB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,OAAe;QACjB,OAAO,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,6BAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACxD;IAEA,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAwB;QACxC,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,KAAK,MAAM,SAAS,IAAI,CAAC,GAAG,CAC1B,MAAM,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO;IAE5C;IAEA,CAAC,UAAoC;QACnC,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,QAAQ,CAAC,GACvC,MAAM;YAAC;YAAO;SAAM;IAExB;IAEA,OAA4B;QAC1B,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;IAEA,SAA8B;QAC5B,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;IAEA,CAAC,CAAA,GAAA,yCAAU,AAAD,EAAE,GAAG;QACb,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,KAAK;IAC3B,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,oCAAc;IAC3B;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,MAAM,MAAM,CAAC;QACb,MAAM,GAAG,CAAC;IACZ;IACA,aAAY,KAAK,EAAE;QACjB,OAAO,IAAI,IAAI;IACjB;AACF;;;AC/FA;AAOA,MAAM,8BAAQ,OAAO;AAEd,MAAM,kDAA4B;IACvC,YAAoB,IAAmC;QACrD,KAAK;mBADa;IAEpB;IAEA,IAAY,MAAiB;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK;IACvB;IAEA,QAAc;QACZ,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,KAAK;QACd,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACxD;IAEA,OAAO,GAAM,EAAW;QACtB,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;QAC5B,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACnC,OAAO;IACT;IAEA,QAAQ,UAAsD,EAAE,OAAa,EAAQ;QACnF,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,MAAQ;YAC/B,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,KAAK;YACnD,WAAW,IAAI,CAAC,SAAS,YAAY,KAAK,IAAI;QAChD,GAAG;QACE,IAAI,CAAC,IAAI;IAChB;IAEA,IAAI,GAAM,EAAiB;QACzB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,GAAM,EAAW;QACnB,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IACtB;IAEA,IAAI,GAAM,EAAE,KAAQ,EAAQ;QAC1B,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;QAC1B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK;QAClB,IAAI,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC;QACtD,OAAO,IAAI;IACb;IAEA,IAAI,OAAe;QACjB,OAAO,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,6BAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACxD;IAEA,+CAA+C,GAC/C,CAAC,CAAC,OAAO,QAAQ,CAAC,GAA6B;QAC7C,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,GAAG,CAAE;YACnC,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC,KAAK;YACnD,MAAM;gBAAC;gBAAK;aAAW;QACzB;IACF;IAEA,UAAoC;QAClC,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;IAC9B;IAEA,OAA4B;QAC1B,IAAI,CAAC,GAAG,CAAC,iBAAiB,CAAC;QAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACtB;IAEA,CAAC,SAA8B;QAC7B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,OAAO,QAAQ,CAAC,GAC9C,MAAM;IAEV;IAEA,CAAC,CAAA,GAAA,yCAAU,AAAD,EAAE,GAAG;QACb,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAEA,CAAA,GAAA,yCAAkB,EAAE,GAAG,CAAC,KAAK;IAC3B,gBAAgB,CAAC,MAAQ;QACvB,OAAO,IAAI,0CAAc;IAC3B;IACA,cAAa,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE;QACxC,MAAM,MAAM,CAAC;QACb,MAAM,GAAG,CAAC,YAAY;IACxB;IACA,aAAY,KAAK,EAAE;QACjB,OAAO,IAAI,IAAI;IACjB;AACF;;;;;ACnGA;;AAGO,SAAS,0CAAgC,IAAO,EAAE;IACvD,MAAM,GAAG,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE,CAAC;IACpC,MAAM,SAAE,MAAK,SAAE,MAAK,WAAE,QAAO,aAAE,UAAS,EAAE,GAAG,CAAA,GAAA,aAAM,AAAD,EAChD,CAAA,GAAA,wCAAa,EAAE,MAAM,IAAM,cAAc,CAAC,KAC1C,OAAO;IAET,4BAA4B;IAC5B;IACA;IAEA,yDAAyD;IACzD,CAAA,GAAA,gBAAS,AAAD,EAAE,IAAM;QACd;IACF;IAEA,2CAA2C;IAC3C,CAAA,GAAA,sBAAe,AAAD,EAAE,IAAM;QACpB,OAAO,IAAM;IACf,GAAG,EAAE;IAEL,OAAO;eAAE;iBAAO;mBAAS;IAAU;AACrC;;","sources":["src/index.ts","src/observables/object-array.ts","src/createObserver.tsx","src/observables/set.ts","src/observables/map.ts","src/react.tsx"],"sourcesContent":["import \"./observables/object-array\";\nimport \"./observables/set\";\nimport \"./observables/map\";\n\nexport {\n  type PublicObservableContext as ObservableContext,\n  createObserver,\n  unwrap,\n  observableFactories,\n} from \"./createObserver\";\n\nexport { objectAndArrayObservableFactory } from \"./observables/object-array\";\n\nexport { useObservable } from \"./react\";\n","import {\n  ObservableFactory,\n  observableFactories,\n  getContext,\n  Observable,\n  unwrap,\n} from \"../createObserver\";\n\nexport const objectAndArrayObservableFactory: ObservableFactory<\n  Record<string | symbol, unknown>,\n  string | symbol\n> = {\n  makeObservable: (ctx) => {\n    return new Proxy(\n      // The target of the proxy is not relevant since we always get/set values directly on the context value object.\n      // We only use the context object to make debugging easier.\n      ctx as any,\n      {\n        has(_, prop) {\n          if (prop === getContext) return true;\n          return Reflect.has(ctx.value, prop);\n        },\n        get(_, prop) {\n          if (prop === getContext) return () => ctx;\n\n          const value = Reflect.get(ctx.value, prop, ctx.value);\n          return ctx.observeIdentifier(prop, value);\n        },\n        set(_, prop, value) {\n          if (prop === getContext) return true;\n\n          const rawValue = unwrap(value);\n          const oldValue = Reflect.get(ctx.value, prop, ctx.value);\n          if (oldValue === rawValue) return true;\n\n          if (Array.isArray(ctx.value)) {\n            const arrayLength = ctx.value.length;\n\n            const setResult = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n\n            if (arrayLength !== ctx.value.length) ctx.modifyIdentifier(\"length\");\n            if (prop !== \"length\") ctx.modifyIdentifier(prop);\n\n            return setResult;\n          }\n\n          const result = Reflect.set(ctx.value, prop, rawValue, ctx.value);\n          ctx.modifyIdentifier(prop);\n          return result;\n        },\n        deleteProperty(_, p): boolean {\n          const result = Reflect.deleteProperty(ctx.value, p);\n          ctx.modifyIdentifier(p);\n          return result;\n        },\n      }\n    ) as Observable;\n  },\n  handleChange(value, identifier, newValue) {\n    value[identifier] = newValue;\n  },\n  createClone(value: any) {\n    if (Array.isArray(value)) return [...value];\n    const clone = { ...value };\n    Object.setPrototypeOf(clone, Object.getPrototypeOf(value));\n    return clone;\n  },\n};\n\nobservableFactories.set(Object, objectAndArrayObservableFactory);\nobservableFactories.set(Array, objectAndArrayObservableFactory);\n","import { Root } from \"react-dom/client\";\n\ninterface SharedRef {\n  identifier: Identifier;\n  value: object;\n  factory: ObservableFactory;\n  parent: SharedRef | undefined;\n  children: Map<Identifier, SharedRef>;\n  observersForId: Map<Identifier, Set<Observer>>;\n  contextForObserver: Map<Observer, ObservableContext>;\n}\n\ninterface RootSharedRef extends SharedRef {\n  __root: true;\n}\n\ninterface Observer {\n  isObserving: boolean;\n  callback: Callback | undefined;\n  disposers: Set<() => void>;\n}\n\nconst rootIdentifier = Symbol(\"root\");\ntype Identifier = unknown | typeof rootIdentifier;\n\nexport interface PublicObservableContext<TValue = any, TMeta = any> {\n  readonly value: TValue;\n  observeIdentifier<T = unknown>(\n    identifier: Identifier,\n    childValue?: T,\n    observeIntermediate?: boolean\n  ): T;\n  modifyIdentifier(childIdentifier: Identifier): void;\n}\n\ninterface ObservableContext<TValue = any, TMeta = any>\n  extends PublicObservableContext<TValue, TMeta> {\n  sharedRef: SharedRef;\n  observer: Observer;\n  readonly observable: Observable;\n  invalidateObservable(): void;\n}\n\nexport type Observable = {\n  [getContext](): PublicObservableContext;\n};\n\ntype Callback = (value: any, identifier: any) => void;\n\n/**\n * The set of supported observable factories. Implement an `ObservableFactory` and add it to this map to add support\n * for custom classes.\n */\nexport const observableFactories = new Map<\n  new (...args: any[]) => any,\n  ObservableFactory<any, any>\n>();\n\nexport const getContext = Symbol(\"getContext\");\n\n/**\n * This interface is used to create observable objects. To create an observable for a class, implement this interface\n * and add it to `observableFactories` using the class as the key.\n */\nexport interface ObservableFactory<TValue = unknown, TIdentifier = unknown> {\n  /**\n   * Returns an object that stands in place of the original value, and can be observed.\n   */\n  makeObservable: (context: ObservableContext<TValue>) => Observable;\n\n  /**\n   * Applies a change to `value` for the given `identifier`.\n   * An example of a change for a plain object would be `value[identifier] = newValue`.\n   */\n  handleChange(value: TValue, identifier: TIdentifier, newValue: unknown): void;\n\n  /**\n   * Returns a clone of `value`.\n   */\n  createClone(value: TValue): object;\n}\n\nconst rootSharedRefs = new Map<unknown, RootSharedRef>();\n\nfunction getSharedRef(\n  identifier: Exclude<Identifier, typeof rootIdentifier>,\n  value: object,\n  parent: SharedRef\n): SharedRef | undefined;\nfunction getSharedRef(identifier: typeof rootIdentifier, value: object): RootSharedRef | undefined;\nfunction getSharedRef(\n  identifier: Identifier,\n  value: object,\n  parent?: SharedRef\n): SharedRef | undefined {\n  let sharedRef = parent ? parent.children.get(identifier) : rootSharedRefs.get(value);\n  if (sharedRef) {\n    sharedRef.value = value;\n    return sharedRef;\n  }\n\n  const factory = observableFactories.get(value.constructor as any);\n  if (!factory) return undefined;\n\n  sharedRef = {\n    identifier,\n    value,\n    children: new Map(),\n    parent,\n    factory,\n    observersForId: new Map(),\n    contextForObserver: new Map(),\n  };\n  if (parent) parent.children.set(identifier, sharedRef);\n  else {\n    (sharedRef as RootSharedRef).__root = true;\n    rootSharedRefs.set(value, sharedRef as RootSharedRef);\n  }\n  return sharedRef;\n}\n\nfunction getObservableContext(observer: Observer, sharedRef: SharedRef): ObservableContext {\n  let ctx = sharedRef.contextForObserver.get(observer);\n  if (ctx) return ctx;\n\n  let observable: Observable | undefined;\n  ctx = {\n    sharedRef,\n    observer,\n    get value() {\n      return this.sharedRef.value;\n    },\n    get observable() {\n      return observable || (observable = this.sharedRef.factory.makeObservable(this));\n    },\n    invalidateObservable() {\n      observable = undefined;\n    },\n    observeIdentifier(identifier, childValue, observeIntermediate = false) {\n      // If the value is a function, bind it to its parent\n      if (typeof childValue === \"function\") {\n        return childValue.bind(this.observable);\n      }\n\n      function addObserver() {\n        if (!observer.isObserving) return;\n        let observers = sharedRef.observersForId.get(identifier);\n        if (!observers) sharedRef.observersForId.set(identifier, (observers = new Set()));\n        observers.add(observer);\n        observer.disposers.add(() => observers!.delete(observer));\n      }\n\n      if (childValue) {\n        // If the property is something we know how to observe, return the observable value\n        const childSharedRef = getSharedRef(identifier, childValue, sharedRef); // TODO: sharedRef.getChildSharedRef(identifier, childValue); ?\n        if (childSharedRef) {\n          if (observeIntermediate) addObserver();\n          return getObservableContext(observer, childSharedRef).observable;\n        }\n      }\n\n      // If it's a non-observable (i.e. a primitive or unknown object type), just observe and return\n      addObserver();\n      return childValue;\n    },\n    modifyIdentifier(childIdentifier) {\n      if (sharedRef.parent) {\n        // Get the factory for the new value\n        sharedRef.factory = observableFactories.get(sharedRef.value.constructor as any)!;\n        // Clone the value\n        sharedRef.value = sharedRef.factory.createClone(sharedRef.value);\n      }\n\n      // Invalidate Observables for all ObservableContexts of the child Identifier\n      sharedRef.children\n        .get(childIdentifier)\n        ?.contextForObserver.forEach((ctx) => ctx.invalidateObservable());\n\n      // Trigger all Observer callbacks for the child Identifier\n      sharedRef.observersForId.get(childIdentifier)?.forEach((observer) => {\n        observer.callback?.(sharedRef.value, childIdentifier);\n      });\n\n      // Let the parent Observable update itself with the cloned child\n      sharedRef.parent?.factory.handleChange(\n        sharedRef.parent!.value,\n        sharedRef.identifier,\n        sharedRef.value\n      );\n\n      // Call modifyIdentifier on the parent/root ObservableContext\n      if (sharedRef.parent)\n        sharedRef.parent?.contextForObserver.get(observer)!.modifyIdentifier(sharedRef.identifier);\n      else if (childIdentifier !== rootIdentifier)\n        sharedRef.contextForObserver.get(observer)!.modifyIdentifier(rootIdentifier);\n    },\n  } as ObservableContext;\n  sharedRef.contextForObserver.set(observer, ctx);\n  return ctx;\n}\n\nexport function createObserver<T extends object>(data: T, callback: Callback) {\n  data = unwrap(data, false);\n  const rootSharedRef = getSharedRef(rootIdentifier, data);\n  if (!rootSharedRef) throw new Error(`Cannot observe value ${data}`);\n\n  const observer: Observer = {\n    isObserving: true,\n    callback,\n    disposers: new Set(),\n  };\n\n  return {\n    store: getObservableContext(observer, rootSharedRef).observable as T,\n    observe() {\n      observer.isObserving = true;\n    },\n    unobserve() {\n      observer.isObserving = false;\n    },\n    reset() {\n      observer.disposers.forEach((disposer) => disposer());\n      observer.disposers.clear();\n    },\n    disable() {\n      observer.isObserving = false;\n      observer.callback = undefined;\n    },\n    enable() {\n      observer.callback = callback;\n    },\n  };\n}\n\nexport function unwrap<T>(observable: T, observe = true): T {\n  const ctx = (observable as Observable)?.[getContext]?.() as ObservableContext;\n  if (!ctx) return observable;\n  if (observe) {\n    if (ctx.sharedRef.parent) {\n      ctx.sharedRef.parent.contextForObserver\n        .get(ctx.observer)\n        ?.observeIdentifier(ctx.sharedRef.identifier, ctx.sharedRef.value, true);\n    } else {\n      ctx.sharedRef.contextForObserver\n        .get(ctx.observer)\n        ?.observeIdentifier(rootIdentifier, observable);\n    }\n  }\n  return ctx.sharedRef.value as T;\n}\n\n/**\n * When an identifier is modified, I need to get all the observers that are observing that identifier, and trigger each callback.\n * I don't want to iterate every existing observer.\n * 1. Get the context's shared ref\n * 2. Use the identifier being modified to get its Set of observers\n * 3. Call each observer's callback\n *\n * When an observation is created:\n * 1. Get the context's shared ref\n * 2. Use the identifier being observed to get its Set of observers\n * 3. Add the observer to the Set\n * 4. Add a cleanup function to the observer that will remove it from the Set on reset\n *\n * When an observer is reset, I need to clear out all of the observers that are observing that identifier for each shared ref.\n * 1. Get the observer\n * 2. Run all the cleanup functions\n *\n * An observable instance needs to compare equal to itself when its underlying value hasn't changed (for things like React's useEffect dependencies)\n *\n */\n","import {\n  PublicObservableContext as ObservableContext,\n  observableFactories,\n  ObservableFactory, getContext\n} from \"../createObserver\";\n\nconst _size = Symbol(\"size\");\n\nclass ObservableSet<T> extends Set<T> {\n  constructor(private ctx: ObservableContext<Set<T>>) {\n    super();\n  }\n\n  private get set(): Set<T> {\n    return this.ctx.value;\n  }\n\n  add(value: T): this {\n    const size = this.set.size;\n    this.set.add(value);\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n    return this;\n  }\n\n  clear(): void {\n    const size = this.set.size;\n    this.set.clear();\n    // this.ctx.childContexts.clear();\n    if (size !== this.set.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(value: T): boolean {\n    const size = this.set.size;\n    const res = this.set.delete(value);\n    if (res) this.ctx.modifyIdentifier(_size);\n    return res;\n  }\n\n  forEach(\n    callbackFn: (value: T, _key: T, set: Set<T>) => void,\n    thisArg?: any\n  ): void {\n    this.set.forEach((value, _key) => {\n      const observable = this.ctx.observeIdentifier(value, value);\n      callbackFn.call(thisArg, observable, observable, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  has(value: T): boolean {\n    this.ctx.observeIdentifier(_size);\n    return this.set.has(value);\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.set.size);\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    this.ctx.observeIdentifier(_size);\n    for (const value of this.set) {\n      yield this.ctx.observeIdentifier(value, value) as T;\n    }\n  }\n\n  *entries(): IterableIterator<[T, T]> {\n    for (const value of this[Symbol.iterator]()) {\n      yield [value, value];\n    }\n  }\n\n  keys(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  values(): IterableIterator<T> {\n    return this[Symbol.iterator]();\n  }\n\n  [getContext]() {\n    return this.ctx;\n  }\n}\n\nobservableFactories.set(Set, {\n  makeObservable: (ctx) => {\n    return new ObservableSet(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.add(newValue);\n  },\n  createClone(value) {\n    return new Set(value);\n  },\n} as ObservableFactory<Set<unknown>, any>);\n","import {\n  PublicObservableContext as ObservableContext,\n  observableFactories,\n  ObservableFactory,\n  getContext,\n} from \"../createObserver\";\n\nconst _size = Symbol(\"size\");\n\nexport class ObservableMap<K, V> extends Map<K, V> {\n  constructor(private ctx: ObservableContext<Map<K, V>>) {\n    super();\n  }\n\n  private get map(): Map<K, V> {\n    return this.ctx.value;\n  }\n\n  clear(): void {\n    const size = this.map.size;\n    this.map.clear();\n    if (size !== this.map.size) this.ctx.modifyIdentifier(_size);\n  }\n\n  delete(key: K): boolean {\n    const res = this.map.delete(key);\n    if (res) this.ctx.modifyIdentifier(key);\n    return res;\n  }\n\n  forEach(callbackFn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    this.map.forEach((value, key) => {\n      const observable = this.ctx.observeIdentifier(key, value);\n      callbackFn.call(thisArg, observable, key, this);\n    }, thisArg);\n    void this.size;\n  }\n\n  get(key: K): V | undefined {\n    this.ctx.observeIdentifier(key);\n    return this.map.get(key);\n  }\n\n  has(key: K): boolean {\n    this.ctx.observeIdentifier(key);\n    return this.map.has(key);\n  }\n\n  set(key: K, value: V): this {\n    const size = this.map.size;\n    this.map.set(key, value);\n    if (size !== this.map.size) this.ctx.modifyIdentifier(key);\n    return this;\n  }\n\n  get size(): number {\n    return this.ctx.observeIdentifier(_size, this.map.size);\n  }\n\n  /** Returns an iterable of entries in the map. */\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    this.ctx.observeIdentifier(_size);\n    for (const [key, value] of this.map) {\n      const observable = this.ctx.observeIdentifier(key, value);\n      yield [key, observable];\n    }\n  }\n\n  entries(): IterableIterator<[K, V]> {\n    return this[Symbol.iterator]();\n  }\n\n  keys(): IterableIterator<K> {\n    this.ctx.observeIdentifier(_size);\n    return this.map.keys();\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [key, value] of this[Symbol.iterator]()) {\n      yield value;\n    }\n  }\n\n  [getContext]() {\n    return this.ctx;\n  }\n}\n\nobservableFactories.set(Map, {\n  makeObservable: (ctx) => {\n    return new ObservableMap(ctx);\n  },\n  handleChange(value, identifier, newValue) {\n    value.delete(identifier);\n    value.set(identifier, newValue);\n  },\n  createClone(value) {\n    return new Map(value);\n  },\n} as ObservableFactory<Map<unknown, unknown>, any>);\n","import React, { useState, useRef, useLayoutEffect, useEffect, useInsertionEffect } from \"react\";\nimport { createObserver } from \"./\";\n\nexport function useObservable<T extends object>(data: T) {\n  const [, forceRerender] = useState({});\n  const { store, reset, observe, unobserve } = useRef(\n    createObserver(data, () => forceRerender({}))\n  ).current;\n\n  // Begin observing on render\n  reset();\n  observe();\n\n  // Stop observing as soon as component finishes rendering\n  useEffect(() => {\n    unobserve();\n  });\n\n  // Disable callback when component unmounts\n  useLayoutEffect(() => {\n    return () => reset();\n  }, []);\n\n  return { store, observe, unobserve };\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}